
struct object {
	to_string
}

struct comparable( object ) {
	compare
}

struct number( comparable ) {
	value;
}

function compare_numbers( ( number ) lhs, ( number ) rhs ) {
	return -( lhs.value rhs.value );
}

function number_to_string( ( number ) this ) {
	return $str( this.value );
}

function new_number( value ) {
	return $new( number @number_to_string @compare_numbers value );
}

# Sort an array of comparable instances.
function qsort( array offset end ) {
	var idx = offset, pivot_idx = idx++;
	var ( comparable ) pivot = [ array pivot_idx ];
	while <( idx end ) {
		if >( :pivot.compare( [ array idx ] ) 0 ) {
			let [ array pivot_idx++ ] = [ array idx ];
			let [ array idx ] = [ array pivot_idx ];
			let [ array pivot_idx ] = pivot;
		}
		inc idx;
	}
	# Select the smallest region for recursion.
	if <( -( pivot_idx offset ) -( end pivot_idx ) ) {
		if >( -( pivot_idx offset ) 1 ) {
			call qsort( array offset pivot_idx );
		}
		let offset = +( pivot_idx 1 );
	} else {
		if >( -( end pivot_idx ) 2 ) {
			call qsort( array +( pivot_idx 1 ) end );
		}
		let end = pivot_idx;
	}
	if <( -( end offset ) 2 ) {
		return 0;
	}
	# Tail-call.
	return qsort( array offset end );
}

function sorted( comparables ) {
	var idx, len = $len( comparables );
	var ( comparable ) prev = [ comparables idx++ ];
	while <( idx len ) {
		var ( comparable ) curr = [ comparables idx++ ];
		if >( :prev.compare( curr ) 0 ) {
			return FALSE;
		}
		let prev = curr;
	}
	return TRUE;
}

function numbers( array ) {
	var idx, len = $len( array ), out = $array( len );
	while <( idx len ) {
		let [ out idx ] = new_number( [ array idx++ ] );
	}
	return out;
}

function random( len ) {
	var array = $array( len ), idx, seed;
	while <( idx len ) {
		let seed = &( +( *( seed 65 ) 17 ) 0x1FFFFFFF );
		#let [ array idx++ ] = -( len idx );
		#let [ array idx ] = idx++;
		let [ array idx++ ] = seed;
	}
	return array;
}

program test {
	var array = numbers( random( 65536 ) );
	print sorted( array );
	call qsort( array 0, $len( array ) );
	print sorted( array );
}
