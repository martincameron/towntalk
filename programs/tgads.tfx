
array palette, charset, foreground, background;

array tg_zorder, tg_type, tg_parent;
array tg_x, tg_y, tg_w, tg_h, tg_min, tg_anchor, tg_mode, tg_link;
array tg_a, tg_b, tg_c, tg_d;

global tg_selx, tg_sely, tg_focus, tg_time;

global fs_win, fs_path, fs_slider, fs_list, fs_file, fs_cancel, fs_okay;

function tg_charset( str ) {
	var w, h, clr, chr, y, x;
	var stride, stroff, chroff;
	let stride = 9;
	if <( $chr( str 9 ) 32 ) {
		let stride = 10;
	}
	let w = *( 8 96 );
	let h = *( 16 $len( palette ) );
	dim [ charset 0 ];
	dim [ charset *( w h ) ];
	let clr = 0;
	while <( clr $len( palette ) ) {
		let stroff = 0;
		let chr = 1;
		while <( chr 95 ) {
			let chroff = +( *( clr *( w 16 ) ) *( chr 8 ) );
			let y = 0;
			while <( y 16 ) {
				let x = 0;
				while <( x 8 ) {
					if >( $chr( str +( stroff x ) ) 32 ) {
						set [ charset +( chroff x ) ] = +( *( [ palette clr ] 256 ) 255 );
					}
					inc x;
				}
				let stroff = +( stroff stride );
				let chroff = +( chroff w );
				inc y;
			}
			inc chr;
		}
		inc clr;
	}
	fxsurface 0, w, h, charset;
}

function tg_text( text, x, y, clr ) {
	var idx, len;
	let len = $len( text );
	while <( idx len ) {
		fxblit 0, *( -( $chr( text idx ) 32 ) 8 ), *( clr 16 ), 8, 16, +( x *( idx 8 ) ), y;
		inc idx;
	}
}

function tg_raise_box( x, y, w, h ) {
	fxrect x, y, 2, h, [ palette 1 ];
	fxrect +( x -( w 2 ) ), y, 2, h, [ palette 0 ];
	fxrect x, y, -( w 1 ), 2, [ palette 1 ];
	fxrect +( x 1 ), +( y -( h 2 ) ), -( w 1 ), 2, [ palette 0 ];
}

function tg_lower_box( x, y, w, h ) {
	fxrect x, y, 2, h, [ palette 0 ];
	fxrect +( x -( w 2 ) ), y, 2, h, [ palette 1 ];
	fxrect x, y, -( w 1 ), 2, [ palette 0 ];
	fxrect +( x 1 ), +( y -( h 2 ) ), -( w 1 ), 2, [ palette 1 ];
}

function tg_bevel_box( x, y, w, h ) {
	call tg_raise_box( x, y, w, h );
	call tg_lower_box( +( x 2 ), +( y 2 ), -( w 4 ), -( h 4 ) );
}

function tg_resize( n, x, y, w, h ) {
	var g, k, a;
	if <( w [ tg_min n ] ) {
		let w = [ tg_min n ];
	}
	if <( h [ tg_min n ] ) {
		let h = [ tg_min n ];
	}
	if =( [ tg_type n ] 1 ) {
		while <( g $len( tg_type ) ) {
			if =( [ tg_parent g ] n ) {
				let k = [ tg_anchor g ];
				if &( k 4 ) {
					if &( k 1 ) {
						let a = +( [ tg_h g ] -( h [ tg_h n ] ) );
						if <( a [ tg_min g ] ) {
							let a = [ tg_min g ];
						}
						set [ tg_h g ] = a;
					} else {
						set [ tg_y g ] = +( [ tg_y g ] -( h [ tg_h n ] ) );
					}
				}
				if &( k 8 ) {
					if &( k 2 ) {
						let a = +( [ tg_w g ] -( w [ tg_w n ] ) );
						if <( a [ tg_min g ] ) {
							let a = [ tg_min g ];
						}
						set [ tg_w g ] = a;
					} else {
						set [ tg_x g ] = +( [ tg_x g ] -( w [ tg_w n ] ) );
					}
				}
			}
			inc g;
		}
	}
	set [ tg_x n ] = x;
	set [ tg_y n ] = y;
	set [ tg_w n ] = w;
	set [ tg_h n ] = h;
}

function tg_minsize( n, size ) {
	set [ tg_min n ] = size;
}

function tg_anchors( n, top, left, bottom, right ) {
	var a;
	if top { let a = |( a 1 ); }
	if left { let a = |( a 2 ); }
	if bottom { let a = |( a 4 ); }
	if right { let a = |( a 8 ); }
	set [ tg_anchor n ] = a;
}

function tg_double_click( n, target ) {
	set [ tg_d n ] = target;
}

function tg_window( n, x, y, w, h, text ) {
	set [ tg_type n ] = 1;
	set [ tg_parent n ] = 0;
	set [ tg_min n ] = 16;
	set [ tg_anchor n ] = 0;
	set [ tg_mode n ] = 1;
	call tg_resize( n, x, y, w, h );
	set [ tg_a n ] = text;
}

function tg_button( n, parent, x, y, w, h, text ) {
	call tg_window( n, x, y, w, h, text );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 2;
}

function tg_vslider( n, parent, x, y, w, h, page, count ) {
	call tg_window( n, x, y, w, h, 0 );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 3;
	set [ tg_b n ] = page;
	set [ tg_c n ] = count;
}

function tg_textbox( n, parent, x, y, w, h, text ) {
	call tg_window( n, x, y, w, h, text );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 4;
}

function tg_sizegad( n, parent, x, y, w, h ) {
	call tg_window( n, x, y, w, h, 0 );
	call tg_anchors( n, 0, 0, 1, 1 );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 5;
}

function tg_listbox( n, parent, x, y, w, h, list, slider ) {
	call tg_window( n, x, y, w, h, list );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 6;
	if >( slider 0 ) {
		set [ tg_link n ] = slider;
		set [ tg_link slider ] = n;
	}
}

function tg_hslider( n, parent, x, y, w, h, page, count ) {
	call tg_window( n, x, y, w, h, 0 );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 7;
	set [ tg_b n ] = page;
	set [ tg_c n ] = count;
}

function tg_box( n, parent, x, y, w, h, style, colour ) {
	call tg_window( n, x, y, w, h, 0 );
	set [ tg_parent n ] = parent;
	set [ tg_type n ] = 8;
	set [ tg_a n ] = style;
	set [ tg_b n ] = colour;
}

function tg_init( gadcount ) {
	var idx;
	dim [ tg_zorder gadcount ];
	dim [ tg_type gadcount ];
	dim [ tg_parent gadcount ];
	dim [ tg_x gadcount ];
	dim [ tg_y gadcount ];
	dim [ tg_w gadcount ];
	dim [ tg_h gadcount ];
	dim [ tg_min gadcount ];
	dim [ tg_anchor gadcount ];
	dim [ tg_mode gadcount ];
	dim [ tg_link gadcount ];
	dim [ tg_a gadcount ];
	dim [ tg_b gadcount ];
	dim [ tg_c gadcount ];
	dim [ tg_d gadcount ];
	while <( idx gadcount ) {
		set [ tg_zorder idx ] = idx;
		inc idx;
	}
}

function tg_draw_background() {
	var y, h;
	let h = $len( background );
	while <( y h ) {
		if <( [ foreground y ] 0 ) {
			fxrect 0, *( y 2 ), 640, 2, [ background y ];
		} else {
			fxrect 0, *( y 2 ), 640, 2, [ foreground y ];
		}
		inc y;
	}
	fxblit 0, 0, 0, 640, 480, 0, 128;
}

function tg_getx( n ) {
	var x;
	let x = [ tg_x n ];
	if >( n 0 ) {
		let x = +( x tg_getx( [ tg_parent n ] ) );
	}
	return x;
}

function tg_gety( n ) {
	var y;
	let y = [ tg_y n ];
	if >( n 0 ) {
		let y = +( y tg_gety( [ tg_parent n ] ) );
	}
	return y;
}

function tg_draw_window( n ) {
	var x, y, w, h;
	let x = tg_getx( n );
	let y = tg_gety( n );
	let w = [ tg_w n ];
	let h = [ tg_h n ];
	fxrect x, y, w, 26, [ palette 2 ];
	fxrect x, +( y 26 ), w, -( h 26 ), [ palette 3 ];
	call tg_raise_box( x, y, w, h );
	call tg_lower_box( +( x 2 ), +( y 24 ), -( w 4 ), -( h 26 ) );
	call tg_text( [ tg_a n ], +( x 6 ), +( y 6 ), 0 );
}

function tg_slider_size( n, p ) {
	return +( /( *( -( p 12 ) [ tg_b n ] ) [ tg_c n ] ) 8 );
}

function tg_slider_offset( n, p ) {
	return /( *( -( p 12 ) [ tg_a n ] ) [ tg_c n ] );
}

function tg_draw_vslider( n ) {
	var x, y, w, h, s, d;
	let x = tg_getx( n );
	let y = tg_gety( n );
	let w = [ tg_w n ];
	let h = [ tg_h n ];
	let s = tg_slider_size( n, h );
	let d = tg_slider_offset( n, h );
	fxrect x, y, w, h, [ palette 3 ];
	call tg_lower_box( x, y, w, h );
	fxrect +( x, 2 ), +( +( y d ) 2 ), -( w 4 ), s, [ palette 2 ];
	call tg_raise_box( +( x, 2 ), +( +( y d ) 2 ), -( w 4 ), s );
}

function tg_draw_hslider( n ) {
	var x, y, w, h, s, d;
	let x = tg_getx( n );
	let y = tg_gety( n );
	let w = [ tg_w n ];
	let h = [ tg_h n ];
	let s = tg_slider_size( n, w );
	let d = tg_slider_offset( n, w );
	fxrect x, y, w, h, [ palette 3 ];
	call tg_lower_box( x, y, w, h );
	fxrect +( +( x d ) 2 ), +( y, 2 ), s, -( h 4 ), [ palette 2 ];
	call tg_raise_box( +( +( x d ) 2 ), +( y, 2 ), s, -( h 4 ) );
}

function tg_draw_button( n ) {
	var x, y, c;
	let x = tg_getx( n );
	let y = tg_gety( n );
	if =( [ tg_b n ] 1 ) {
		let c = 1;
		fxrect x, y, [ tg_w n ], [ tg_h n ], [ palette 3 ];
		call tg_lower_box( x, y, [ tg_w n ], [ tg_h n ] );
	} else {
		fxrect x, y, [ tg_w n ], [ tg_h n ], [ palette 2 ];
		call tg_raise_box( x, y, [ tg_w n ], [ tg_h n ] );
	}
	call tg_text( [ tg_a n ],
		+( x /( -( [ tg_w n ] *( $len( [ tg_a n ] ) 8 ) ) 2 ) ),
		+( y /( -( [ tg_h n ] 14 ) 2 ) ), c );
}

function tg_draw_textbox( n ) {
	var x, y, t, c;
	let x = tg_getx( n );
	let y = tg_gety( n );
	let t = [ tg_a n ];
	let c = /( -( [ tg_w n ] 16 ) 8 );
	if >( $len( t ) c ) {
		let t = $sub( t, -( $len( t ) c ), c );
	}
	fxrect x, y, [ tg_w n ], [ tg_h n ], [ palette 2 ];
	if =( [ tg_b n ] 1 ) {
		fxrect +( x *( +( $len( t ) 1 ) 8 ) ), +( y 6 ), 8, 16, [ palette 3 ];
	}
	call tg_bevel_box( x, y, [ tg_w n ], [ tg_h n ] );
	call tg_text( t, +( x 8 ), +( y 6 ), 0 );
}

function tg_draw_sizegad( n ) {
	var x, y;
	let x = tg_getx( n );
	let y = tg_gety( n );
	fxrect x, y, [ tg_w n ], [ tg_h n ], [ palette 2 ];
	call tg_raise_box( x, y, [ tg_w n ], [ tg_h n ] );
}

function tg_draw_listbox( n ) {
	var x, y, tw, th, idx, end, ty, tc, txt;
	if >( [ tg_link n ] 0 ) {
		call tg_listbox_scroll( n, [ tg_link n ] );
		call tg_draw( [ tg_link n ] );
	}
	let x = tg_getx( n );
	let y = tg_gety( n );
	fxrect x, y, [ tg_w n ], [ tg_h n ], [ palette 2 ];
	call tg_lower_box( x, y, [ tg_w n ], [ tg_h n ] );
	let tw = /( -( [ tg_w n ] 16 ) 8 );
	let th = /( -( [ tg_h n ] 12 ) 16 );
	if >( +( [ tg_b n ] th ) $len( [ tg_a n ] ) ) {
		let th = -( $len( [ tg_a n ] ) [ tg_b n ] );
	}
	let ty = +( y 6 );
	let idx = [ tg_b n ];
	let end = +( idx th );
	while <( idx end ) {
		let txt = [ [ tg_a n ] idx ];
		let tc = $tup( 0, txt );
		if =( [ tg_c n ] idx ) {
			fxrect +( x 8 ), ty, -( [ tg_w n ] 16 ), 16, [ palette 3 ];
			let tc = 1;
		}
		if >( $len( txt ) tw ) {
			let txt = $sub( txt, 0, tw );
		}
		call tg_text( txt, +( x 8 ), ty, tc );
		let ty = +( ty 16 );
		inc idx;
	}
}

function tg_draw_box( n ) {
	var x, y;
	let x = tg_getx( n );
	let y = tg_gety( n );
	if >e( [ tg_b n ] 0 ) {
		fxrect x, y, [ tg_w n ], [ tg_h n ], [ tg_b n ];
	}
	switch [ tg_a n ] {
		case 1 {
			call tg_raise_box( x, y, [ tg_w n ], [ tg_h n ] );
		}
		case 2 {
			call tg_lower_box( x, y, [ tg_w n ], [ tg_h n ] );
		}
		default {
			call tg_bevel_box( x, y, [ tg_w n ], [ tg_h n ] );
		}
	}
}

function tg_draw( n ) {
	var type, mode, idx, len;
	if <( n 1 ) {
		let type = 1;
		let mode = 1;
	} else {
		let type = [ tg_type n ];
		let mode = [ tg_mode n ];
	}
	if >( mode 0 ) {
		switch type {
			case 1 {
				if <( n 1 ) {
					call tg_draw_background();
				} else {
					call tg_draw_window( n );
				}
				let idx = 1;
				let len = $len( tg_zorder );
				while <( idx len ) {
					if =( [ tg_parent [ tg_zorder idx ] ] n ) {
						call tg_draw( [ tg_zorder idx ] );
					}
					inc idx;
				}
			}
			case 2 { call tg_draw_button( n ); }
			case 3 { call tg_draw_vslider( n ); }
			case 4 { call tg_draw_textbox( n ); }
			case 5 { call tg_draw_sizegad( n ); }
			case 6 { call tg_draw_listbox( n ); }
			case 7 { call tg_draw_hslider( n ); }
			case 8 { call tg_draw_box( n ); }
		}
	}
}

function tg_listbox_scroll( listbox, slider ) {
	# Adjust slider to listbox size (if changed).
	set [ tg_b slider ] = /( -( [ tg_h listbox ] 12 ) 16 );
	set [ tg_c slider ] = $len( [ tg_a listbox ] );
	if >( [ tg_b slider ] [ tg_c slider ] ) {
		set [ tg_b slider ] = [ tg_c slider ];
	}
	if >( +( [ tg_a slider ] [ tg_b slider ] ) [ tg_c slider ] ) {
		set [ tg_a slider ] = -( [ tg_c slider ] [ tg_b slider ] );
	}
	if <( [ tg_a slider ] 0 ) {
		set [ tg_a slider ] = 0;
	}
	# Set listbox offset.
	set [ tg_b listbox ] = [ tg_a slider ];
}

function tg_find( x, y, p ) {
	var n, idx, len, g, x0, y0, x1, y1, mode, wins;
	let n = p;
	let len = $len( tg_zorder );
	let idx = 1;
	while <( idx len ) {
		let g = [ tg_zorder idx ];
		if &&( =( [ tg_parent g ] p ) >( [ tg_mode g ] 0 ) ) {
			if <( mode [ tg_mode g ] ) {
				let mode = [ tg_mode g ];
			}
			if =( [ tg_type g ] 1 ) {
				inc wins;
			}
		}
		inc idx;
	}
	let idx = 1;
	while <( idx len ) {
		let g = [ tg_zorder idx ];
		if &&( =( [ tg_parent g ] p ) >( [ tg_mode g ] 0 ) ) {
			let x0 = [ tg_x g ];
			let y0 = [ tg_y g ];
			let x1 = +( x0 [ tg_w g ] );
			let y1 = +( y0 [ tg_h g ] );
			if &&( &&( >e( x x0 ) >e( y y0 ) ) &&( <( x x1 ) <( y y1 ) ) ) {
				if =( [ tg_mode g ] mode ) {
					if =( [ tg_type g ] 1 ) {
						let n = tg_find( -( x x0 ), -( y y0 ), g );
					} else {
						if ||( >( [ tg_parent g ] 0 ) =( wins 0 ) ) {
							let n = g;
						}
					}
				}
			}
		}
		inc idx;
	}
	return n;
}

function tg_wintofront( n ) {
	var idx, end, g;
	while >( [ tg_type n ] 1 ) {
		let n = [ tg_parent n ];
	}
	let end = -( $len( tg_zorder ) 1 );
	if &&( >( n 0 ) !( =( [ tg_zorder end ] n ) ) ) {
		let idx = 1;
		while <( idx $len( tg_zorder ) ) {
			let g = [ tg_zorder -( idx 1 ) ];
			if =( g n ) {
				set [ tg_zorder -( idx 1 ) ] = [ tg_zorder idx ];
				set [ tg_zorder idx ] = g;
			}
			inc idx;
		}
		call tg_draw( [ tg_zorder end ] );
	}
	return n;
}

function tg_dispose( n ) {
	var idx, end;
	let idx = 1;
	let end = $len( tg_parent );
	while <( idx end ) {
		if =( [ tg_parent idx ] n ) {
			call tg_dispose( idx );
		}
		inc idx;
	}
	set [ tg_type n ] = 0;
	set [ tg_parent n ] = 0;
	set [ tg_mode n ] = 0;
	set [ tg_link n ] = 0;
	set [ tg_a n ] = 0;
	set [ tg_b n ] = 0;
	set [ tg_c n ] = 0;
	set [ tg_d n ] = 0;
}

function tg_num_unused() {
	var idx, end, num;
	let idx = 1;
	let end = $len( tg_type );
	while <( idx end ) {
		if =( [ tg_type idx ] 0 ) {
			inc num;
		}
		inc idx;
	}
	return num;
}

function tg_unused() {
	var idx, end;
	let idx = 1;
	let end = $len( tg_zorder );
	while <( idx end ) {
		if =( [ tg_type [ tg_zorder idx ] ] 0 ) {
			return [ tg_zorder idx ];
		}
		inc idx;
	}
}

function tg_scan( event ) {
	var n, s, o, p, e, t, c, w, x, y, selected;
	switch event {
		case FX_MOUSEMOTION {
			if =( $mousekey 1 ) {
				if =( tg_selx 0 ) {
					let tg_selx = $xmouse;
					let tg_sely = $ymouse;
				}
				let n = tg_find( tg_selx, tg_sely, 0 );
				let w = tg_wintofront( n );
				switch [ tg_type n ] {
					case 1 {
						let x = $xmouse;
						let y = $ymouse;
						set [ tg_x n ] = -( +( [ tg_x n ] x ) tg_selx );
						set [ tg_y n ] = -( +( [ tg_y n ] y ) tg_sely );
						let tg_selx = x;
						let tg_sely = y;
						call tg_draw( 0 );
					}
					case 2 {
						if =( tg_find( $xmouse, $ymouse, 0 ) n ) {
							set [ tg_b n ] = 1;
						} else {
							set [ tg_b n ] = 0;
						}
						call tg_draw( n );
					}
					case 3 {
						let s = tg_slider_size( n, [ tg_h n ] );
						let o = tg_slider_offset( n, [ tg_h n ] );
						let e = -( -( [ tg_h n ] 4 ) s );
						let y = +( +( tg_gety( n ) o ) 2 );
						if &&( >( tg_sely y ) <( tg_sely +( y s ) ) ) {
							let p = +( o -( $ymouse tg_sely ) );
							if <( p 0 ) {
								let p = 0;
							}
							if >( p e ) {
								let p = e;
							}
							if >( p 0 ) {
								set [ tg_a n ] = /( *( p -( [ tg_c n ] [ tg_b n ] ) ) e );
							} else {
								set [ tg_a n ] = 0;
							}
							let tg_sely = +( tg_sely -( tg_slider_offset( n, [ tg_h n ] ) o ) );
							let selected = n;
							if >( [ tg_link n ] 0 ) {
								call tg_draw( [ tg_link n ] );
							} else {
								call tg_draw( n );
							}
						}
					}
					case 5 {
						let x = $xmouse;
						let y = $ymouse;
						let o = -( tg_selx tg_getx( n ) );
						let p = -( tg_sely tg_gety( n ) );
						call tg_resize( w, [ tg_x w ], [ tg_y w ], 
							-( +( [ tg_w w ] x ) tg_selx ),
							-( +( [ tg_h w ] y ) tg_sely ) );
						let tg_selx = +( tg_getx( n ) o );
						let tg_sely = +( tg_gety( n ) p );
						let selected = w;
						call tg_draw( 0 );
					}
					case 7 {
						let s = tg_slider_size( n, [ tg_w n ] );
						let o = tg_slider_offset( n, [ tg_w n ] );
						let e = -( -( [ tg_w n ] 4 ) s );
						let x = +( +( tg_getx( n ) o ) 2 );
						if &&( >( tg_selx x ) <( tg_selx +( x s ) ) ) {
							let p = +( o -( $xmouse tg_selx ) );
							if <( p 0 ) {
								let p = 0;
							}
							if >( p e ) {
								let p = e;
							}
							if >( p 0 ) {
								set [ tg_a n ] = /( *( p -( [ tg_c n ] [ tg_b n ] ) ) e );
							} else {
								set [ tg_a n ] = 0;
							}
							let tg_selx = +( tg_selx -( tg_slider_offset( n, [ tg_w n ] ) o ) );
							let selected = n;
							call tg_draw( n );
						}
					}
				}
			}
		}
		case FX_MOUSEKEYDOWN {
			let tg_selx = 0;
			let tg_sely = 0;
			if =( $mousekey 1 ) {
				let tg_selx = $xmouse;
				let tg_sely = $ymouse;
				let n = tg_find( tg_selx, tg_sely, 0 );
				if =( [ tg_type tg_focus ] 4 ) {
					set [ tg_b tg_focus ] = 0;
					call tg_draw( tg_focus );
				}
				let tg_focus = n;
				let w = tg_wintofront( n );
				switch [ tg_type n ] {
					case 2 {
						set [ tg_b n ] = 1;
						call tg_draw( n );
					}
					case 3 {
						let s = tg_slider_size( n, [ tg_h n ] );
						let o = tg_slider_offset( n, [ tg_h n ] );
						let e = -( -( [ tg_h n ] 4 ) s );
						let y = +( +( tg_gety( n ) o ) 2 );
						if <( tg_sely y ) {
							let t = -( [ tg_a n ] [ tg_b n ] );
							if <( t 0 ) {
								let t = 0;
							}
							set [ tg_a n ] = t;
							let selected = n;
							if >( [ tg_link n ] 0 ) {
								call tg_draw( [ tg_link n ] );
							} else {
								call tg_draw( n );
							}
						}
						if >( tg_sely +( y s ) ) {
							let t = +( [ tg_a n ] [ tg_b n ] );
							if >( t -( [ tg_c n ] [ tg_b n ] ) ) {
								let t = -( [ tg_c n ] [ tg_b n ] );
							}
							set [ tg_a n ] = t;
							let selected = n;
							if >( [ tg_link n ] 0 ) {
								call tg_draw( [ tg_link n ] );
							} else {
								call tg_draw( n );
							}
						}
					}
					case 4 {
						set [ tg_b n ] = 1;
						call tg_draw( n );
					}
					case 6 {
						let s = +( [ tg_b n ] /( -( tg_sely +( tg_gety( n ) 6 ) ) 16 ) );
						if &&( =( s [ tg_c n ] ) <( -( $millis tg_time ) 500 ) ){
							let selected = [ tg_d n ];
							let tg_time = 0;
						} else {
							if <( s $len( [ tg_a n ] ) ) {
								set [ tg_c n ] = s;
								let selected = n;
							}
							let tg_time = $millis;
						}
						call tg_draw( n );
					}
					case 7 {
						let s = tg_slider_size( n, [ tg_w n ] );
						let o = tg_slider_offset( n, [ tg_w n ] );
						let e = -( -( [ tg_w n ] 4 ) s );
						let x = +( +( tg_getx( n ) o ) 2 );
						if <( tg_selx x ) {
							let t = -( [ tg_a n ] [ tg_b n ] );
							if <( t 0 ) {
								let t = 0;
							}
							set [ tg_a n ] = t;
							let selected = n;
							call tg_draw( n );
						}
						if >( tg_selx +( x s ) ) {
							let t = +( [ tg_a n ] [ tg_b n ] );
							if >( t -( [ tg_c n ] [ tg_b n ] ) ) {
								let t = -( [ tg_c n ] [ tg_b n ] );
							}
							set [ tg_a n ] = t;
							let selected = n;
							call tg_draw( n );
						}
					}
				}
				if &&( selected !( =( selected n ) ) ) {
					let tg_selx = 0;
					let tg_sely = 0;
				}
			}
		}
		case FX_MOUSEKEYUP {
			if ||( tg_selx tg_sely ) {
				let n = tg_find( tg_selx, tg_sely, 0 );
				switch [ tg_type n ] {
					case 2 {
						set [ tg_b n ] = 0;
						call tg_draw( n );
						if =( tg_find( $xmouse, $ymouse, 0 ) n ) {
							let selected = n;
						}
					}
				}
				let tg_selx = 0;
				let tg_sely = 0;
			}
		}
		case FX_KEYDOWN {
			if =( [ tg_type tg_focus ] 4 ) {
				let t = [ tg_a tg_focus ];
				let c = $keyboard;
				if =( c 8 ) {
					if >( $len( t ) 0 ) {
						if &( $keyshift 3 ) {
							let t = "";
						} else {
							let t = $sub( t, 0, -( $len( t ) 1 ) );
						}
						set [ tg_a tg_focus ] = t;
					}
				} else {
					if >( c 31 ) {
						if &( $keyshift 3 ) {
							if <( c 64 ) {
								let c = $chr( " !\"~$%&@()*+<_>?)!\"#$%^&*(::<+>?@", -( c 32 ) );
							} else {
								if <( c 96 ) {
									let c = +( c 32 );
								} else {
									let c = -( c 32 );
								}
							}
						}
						if <( c 127 ) {
							set [ tg_a tg_focus ] = $str( t, $asc( c ) );
						}
					}
				}
				let selected = tg_focus;
				call tg_draw( tg_focus );
			}
		}
	}
	return selected;
}

function sort_dir( vals ) {
	var progress, idx, tmp, lhs, rhs;
	let progress = TRUE;
	while progress {
		let idx = 1;
		let progress = FALSE;
		while <( idx $len( vals ) ) {
			let tmp = [ vals -( idx 1 ) ];
			if <( tmp 0 ) {
				let lhs = tmp;
			} else {
				let lhs = $tup( tmp, 0 );
			}
			if <( [ vals idx ] 0 ) {
				let rhs = [ vals idx ];
			} else {
				let rhs = $tup( [ vals idx ] 0 );
			}
			if >( $cmp( lhs rhs ) 0 ) {
				set [ vals -( idx 1 ) ] = [ vals idx ];
				set [ vals idx ] = tmp;
				let progress = TRUE;
			}
			inc idx;
		}
	}
}

function format_dir( vals ) {
	var idx, len;
	while <( idx $len( vals ) ) {
		if <( [ vals idx ] 0 ) {
			set [ vals idx ] = $tup( $str( "[Dir] " [ vals idx ] ) 1 ); 
		} else {
			let len = $tup( 0 [ vals idx ] );
			if >( len 9999 ) {
				if >( len *( 1048576 2047 ) ) {
					let len = "(+2g)";
				} else {
					if >( len *( 1024 9999 ) ) {
						let len = $str( /( len 1048576 ) "m");
					} else {
						let len = $str( /( len 1024 ) "k");
					}
				}
			} else {
				let len = $str( len );
			}
			while <( $len( len ) 5 ) {
				let len = $str( " " len );
			}
			set [ vals idx ] = $tup( $str( len " " [ vals idx ] ) 0 ); 
		}
		inc idx;
	}
}

function tg_file_selector( title ) {
	if fs_win {
		call tg_dispose( fs_win );
	}
	if <( tg_num_unused() 8 ) {
		throw "Not enough free gadgets.";
	}
	let fs_win = tg_unused();
	call tg_window( fs_win, 50, 50, 510, 270, title );
	set [ tg_mode fs_win ] = 2;
	set [ tg_min fs_win ] = 200;
	call tg_sizegad( tg_unused(), fs_win, 490, 250, 16, 16 );
	let fs_path = tg_unused();
	call tg_textbox( fs_path, fs_win, 10, 32, 380, 28, $fxpath( "." ) );
	call tg_anchors( fs_path, 1, 1, 0, 1 );
	let fs_slider = tg_unused();
	call tg_vslider( fs_slider, fs_win, 396, 32, 20, 226, 10, 100 );
	call tg_anchors( fs_slider, 1, 0, 1, 1 );
	let fs_list = tg_unused();
	call tg_listbox( fs_list, fs_win, 10, 64, 380, 160, $fxdir( "." ), fs_slider );
	call tg_anchors( fs_list, 1, 1, 1, 1 );
	call sort_dir( [ tg_a fs_list ] );
	call format_dir( [ tg_a fs_list ] );
	let fs_file = tg_unused();
	call tg_textbox( fs_file, fs_win, 10, 230, 380, 28, $tup( "." 1 ) );
	call tg_anchors( fs_file, 0, 1, 1, 1 );
	let fs_cancel = tg_unused();
	call tg_button( fs_cancel, fs_win, 422, 32, 80, 28, "Cancel" );
	call tg_anchors( fs_cancel, fs_win, 0, 0, 1 );
	let fs_okay = tg_unused();
	call tg_button( fs_okay, fs_win, 422, 64, 80, 28, "Okay" );
	call tg_anchors( fs_okay, 1, 0, 0, 1 );
	call tg_double_click( fs_list, fs_okay );
	call tg_wintofront( fs_win );
	call tg_draw( 0 );
}

function fs_dispose() {
	call tg_dispose( fs_win );
	let fs_win = 0;
	let fs_path = 0;
	let fs_slider = 0;
	let fs_list = 0;
	let fs_file = 0;
	let fs_cancel = 0;
	let fs_okay = 0;
	call tg_draw( 0 );
}

function fs_list_selected() {
	var file;
	let file = [ [ tg_a fs_list ] [ tg_c fs_list ] ];
	set [ tg_a fs_file ] = $tup( $sub( file, 6, -( $len( file ) 6 ) ), file );
	call tg_draw( fs_file );
}

function fs_okay_selected() {
	var sep, path, file, err;
	let sep = $chop( [ tg_a fs_path ], "/:\\" );
	let sep = $sub( sep, -( $len( sep ) 1 ), 1 );
	if >( [ tg_a fs_file ] 0 ) {
		try {
			let path = $fxpath( $str( [ tg_a fs_path ] sep [ tg_a fs_file ] ) );
			set [ tg_a fs_list ] = $fxdir( path );
			call sort_dir( [ tg_a fs_list ] );
			call format_dir( [ tg_a fs_list ] );
			set [ tg_b fs_list ] = 0;
			set [ tg_c fs_list ] = 0;
			set [ tg_a fs_slider ] = 0;
			let file = [ [ tg_a fs_list ] 0 ];
			set [ tg_a fs_path ] = path;
			set [ tg_a fs_file ] = $tup( $sub( file, 6, -( $len( file ) 6 ) ) file );
		} catch err {
			let err = $chop( $str( err ) "(" );
			set [ tg_a fs_file ] = $sub( err, 0, -( $len( err ) 2 ) );
		}
		call tg_draw( fs_win );
	} else {
		let file = $str( [ tg_a fs_path ] sep [ tg_a fs_file ] );
		call fs_dispose();
		return file;
	}
}

function gradient( c1, c2, out, off, len ) {
	var r1, r2, g1, g2, b1, b2, r, g, b, idx;
	let r1 = &( >>( c1 16 ) 0xFF );
	let r2 = &( >>( c2 16 ) 0xFF );
	let g1 = &( >>( c1 8 ) 0xFF );
	let g2 = &( >>( c2 8 ) 0xFF );
	let b1 = &( c1 0xFF );
	let b2 = &( c2 0xFF );
	while <( idx len ) {
		let r = +( r1 /( *( -( r2 r1 ) idx ) len ) );
		let g = +( g1 /( *( -( g2 g1 ) idx ) len ) );
		let b = +( b1 /( *( -( b2 b1 ) idx ) len ) );
		set [ out +( off idx ) ] = +( *( r 65536 ) +( *( g 256 ) b ) );
		inc idx;
	}
}

function parse_rws( rws, out ) {
	var elem, idx, a, c, r, g, b;
	let elem = $parse( rws );
	if $cmp( elem, "RM.AGA" ) {
		if $cmp( elem, "RW.SCN" ) {
			throw "Not an RWS file.";
		}
	} else {
		let a = TRUE;
	}
	let elem = $next( elem );
	while $cmp( elem, "EOF" ) {
		if <( idx $len( out ) ) {
			let c = $int( elem );
			if !( a ) {
				let r = *( &( >>( c 8 ) 0xF ) 16 );
				let g = *( &( >>( c 4 ) 0xF ) 16 ); 
				let b = *( &( c 0xF ) 16 ); 
				let c = +( *( r 65536 ) +( *( g 256 ) b ) );
			}
			set [ out idx ] = c;
			inc idx;
		}
		let elem = $next( elem );
	}
}

function fill_array( arr, value ) {
	var idx;
	while <( idx $len( arr ) ) {
		set [ arr idx ] = value;
		inc idx;
	}
}

function fore_to_back() {
	var y;
	while <( y $len( foreground ) ) {
		if >( [ foreground y ] -1 ) {
			set [ background y ] = [ foreground y ];
			set [ foreground y ] = -1;
		}
		inc y;
	}
}

function dither( source, dest ) {
	var y, r, g, b;
	while <( y $len( source ) ) {
		let r = +( r &( [ source y ] 0xFF0000 ) );
		if >( r 0xFF0000 ) {
			let r = 0xFF0000;
		}
		let g = +( g &( [ source y ] 0xFF00 ) );
		if >( g 0xFF00 ) {
			let g = 0xFF00;
		}
		let b = +( b &( [ source y ] 0xFF ) );
		if >( b 0xFF ) {
			let b = 0xFF;
		}
		set [ dest y ] = &( +( r +( g b ) ) 0xF0F0F0 );
		let r = &( r 0xF0000 );
		let g = &( g 0xF00 );
		let b = &( b 0xF );
		inc y;
	}
}

program tgads {
	var idx, event, selected, file, err, y, c1, c2, paint;
	let palette = $array( ${ 0x000000, 0xFFFFFF, 0xA0A0A0, 0x6080B0 } );

	dim [ foreground 240 ];
	call fill_array( foreground, -1 );

	dim [ background 240 ];
	call parse_rws( $load( $str( $chop( $src, "/:\\" ) "rws/demo5.rws" ) ), background );

	call tg_charset( $load( $str( $chop( $src, "/:\\" ) "topaz8.txt" ) ) );

	fxopen 640, 480, "tgads";

	call tg_init( 25 );

	call tg_window( 1, 10, 10, 256, 256, "Window" );
	
	call tg_button( 2, 1, 10, 32, 80, 26, "Load" );
	call tg_button( 3, 1, 10, 64, 80, 26, "Save" );
	call tg_button( 4, 1, 10, 96, 80, 26, "Undo" );
	call tg_button( 5, 1, 10, 128, 80, 26, "Dither" );
	call tg_button( 6, 1, 10, 160, 80, 26, "Quit" );
	
	#call tg_box( 9, 1, 100, 32, 144, 190, 0, [ palette 3 ] );
	
	call tg_hslider( 10, 1, 108,  40, 128, 20, 32, 287 );
	call tg_hslider( 11, 1, 108,  65, 128, 20, 32, 287 );
	call tg_hslider( 12, 1, 108,  90, 128, 20, 32, 287 );
	
	call tg_hslider( 13, 1, 108, 140, 128, 20, 32, 287 );
	call tg_hslider( 14, 1, 108, 165, 128, 20, 32, 287 );
	call tg_hslider( 15, 1, 108, 190, 128, 20, 32, 287 );

	print $cat( tg_num_unused() " unused gadgets at " tg_unused() );
		
	call tg_draw( 0 );
	fxshow;

	while TRUE {
		let event = $fxwait;
		let selected = tg_scan( event );
		if >( selected 0 ) {
			#print $cat( selected, " ", [ tg_a selected ] );
			switch selected {
				case 2 {
					call tg_file_selector( "Load RMS/RWS" );
				}
				case 3 {
					call tg_file_selector( $tup( "Save RMS" 1 ) );
				}
				case 4 {
					call fill_array( foreground, -1 );
					call tg_draw( 0 );
				}
				case 5 {
					call fore_to_back();
					call dither( background, foreground );
					call tg_draw( 0 );
				}
				case 6 {
					break;
				}
				case 10 {
					let c1 = +( +( *( [ tg_a 10 ] 65536 ) *( [ tg_a 11 ] 256 ) ) [ tg_a 12 ] );
				}
				case 11 {
					let c1 = +( +( *( [ tg_a 10 ] 65536 ) *( [ tg_a 11 ] 256 ) ) [ tg_a 12 ] );
				}
				case 12 {
					let c1 = +( +( *( [ tg_a 10 ] 65536 ) *( [ tg_a 11 ] 256 ) ) [ tg_a 12 ] );
				}
				case 13 {
					let c2 = +( +( *( [ tg_a 13 ] 65536 ) *( [ tg_a 14 ] 256 ) ) [ tg_a 15 ] );
				}
				case 14 {
					let c2 = +( +( *( [ tg_a 13 ] 65536 ) *( [ tg_a 14 ] 256 ) ) [ tg_a 15 ] );
				}
				case 15 {
					let c2 = +( +( *( [ tg_a 13 ] 65536 ) *( [ tg_a 14 ] 256 ) ) [ tg_a 15 ] );
				}
				case fs_list {
					call fs_list_selected();
				}
				case fs_cancel {
					call fs_dispose();
				}
				case fs_okay {
					try {
						if =( [ tg_a fs_win ] 1 ) {
							let file = fs_okay_selected();
							if file {
								call fore_to_back();
								save $str( "RM.AGA\012" $astr( background ) "EOF" ), file;
							}
						} else {
							let file = fs_okay_selected();
							if file {
								call fill_array( foreground, -1 );
								call parse_rws( $load( file ), background );
								call tg_draw( 0 );
							}
						}
					} catch err {
						print err;
					}
				}
			}
		} else {
			if =( $mousekey 1 ) {
				if &&( tg_selx =( tg_find( tg_selx, tg_sely, 0 ) 0 ) ) {
					if =( paint FALSE ) {
						call fore_to_back();
						let paint = TRUE;
					}
					let y = $ymouse;
					call fill_array( foreground, -1 );
					if <( tg_sely y ) {
						call gradient( c1, c2, foreground, /( tg_sely 2 ), /( -( y tg_sely ) 2 ) );
					} else {
						call gradient( c2, c1, foreground, /( y 2 ), /( -( tg_sely y ) 2 ) );
					}
					call tg_draw(0);
				}
			} else {
				let paint = FALSE;
			}
		}
		fxshow;
	}
	print "Bye!";
}
