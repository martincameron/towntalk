
import wavegen from "wavegen.tt";

/*
	Micromod Compiler for Towntalk.
*/
library mmc {
	const VERSION = "20260219";
	const HEX_TO_STRING = "0123456789ABCDEF";
	const KEY_TO_STRING = "A-A#B-C-C#D-D#E-F-F#G-G#";
	const STRING_TO_KEY = $pack( $buffer( 8 -2, 0, 1, 3, 5, 6, 8, 10 ) );
	const KEY_TO_PERIOD = $pack( $buffer( 74, 1814,
		/* C-0   C#0   D-0   D#0   E-0   F-0   F#0   G-0   G#0   A-1  A#1  B-1 */
		  1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016, 960, 907,
		   856,  808,  762,  720,  678,  640,  604,  570,  538,  508, 480, 453,
		   428,  404,  381,  360,  339,  320,  302,  285,  269,  254, 240, 226,
		   214,  202,  190,  180,  170,  160,  151,  143,  135,  127, 120, 113,
		   107,  101,   95,   90,   85,   80,   75,   71,   67,   63,  60,  56,
		    53,   50,   47,   45,   42,   40,   37,   35,   33,   31,  30,  28, 26
	) );
	
	function note_info() {
		return $array( 64 ""
			"An 8-character ProTracker note takes the form 'KKOIIFPP', where:"
			""
			"    KK = Key (One of 'C-', 'C#', 'D-', 'D#', 'E-', 'F-', 'F#',"
			"                     'G-', 'G#', 'A-', 'A#', 'B-', or '--')."
			"    O  = Octave (0 to 6, or '-')."
			"    II = Instrument or macro index (Decimal, 01 to 99, or '--')."
			"    F  = Effect Command (Hexadecimal, 0 to F, or '-')."
			"    PP = Effect Parameter (Hexadecimal, 00 to FF, or '--')."
			""
			"For example, an empty note would be '--------', and instrument 1"
			"played at middle-c, with no effect would be 'C-201---'."
			"The channel volume and fine-tune are set from the instrument."
			""
			"When a macro is played instead of an instrument, it will run until"
			"a note with an instrument is encountered. The transpose and volume"
			"of a macro can be adjusted by using a key or set volume (effect C)"
			"in the pattern. When the end of the pattern is reached, the macro"
			"will continue to run into the next pattern in the sequence."
			""
			"The available effect/parameter combinations are:"
			""
			"    0xy = Arpeggio, rapidly cycle through key, key + x, key + y."
			"    1xx = Portamento up with speed xx."
			"    1Fx = Portamento up with speed x semitones per row (Macro only)."
			"    2xx = Portamento down with speed xx."
			"    2Fx = Portamento down with speed x semitones per row (Macro only)."
			"    3xx = Tone portamento, slide towards the current key at speed xx."
			"    3Fx = Tone portamento with speed x semitones per row (Macro only)."
			"    4xy = Vibrato with speed x, depth y."
			"    5xy = Continue tone portamento with volume-slide speed (x - y)."
			"    6xy = Continue vibrato with volume slide speed (x - y)."
			"    7xx = Tremolo with speed x, depth y."
			"    8xx = Set panning 00 to 7F. Not for 4-channel modules."
			"    9xx = Set sample offset to xx * 256 samples."
			"    9Fx = Increase sample offset by x * length / 64 (Macro only)."
			"    Axy = Volume slide with speed (x - y)."
			"    AxF = Linear volume-slide up with speed x (Macro only)."
			"    AFx = Linear volume-slide down with speed x (Macro only)."
			"    Bxx = Pattern jump to pattern xx."
			"    Cxx = Set volume of instrument or macro to xx (00 to 40)."
			"    CFx = Linear set volume x (Macro only)."
			"    Dnn = Pattern break, to row nn (decimal 00 to 63) of next pattern."
			"    E1x = Fine portamento up with speed x."
			"    E2x = Fine portamento down with speed x."
			"    E3x = Glissando. (Not supported in Micromod)."
			"    E4x = Set vibrato waveform x (Sine 0, Saw 1, Square 2, Random 3)."
			"    E5x = Set channel fine-tune x eighths of a semitone."
			"    E60 = Set pattern loop marker."
			"    E6x = Pattern loop (replay from the marker x times)."
			"    E7x = Set tremolo waveform x (Sine 0, Saw 1, Square 2, Random 3)."
			"    E9x = Retrigger sample every x ticks."
			"    EAx = Fine volume-slide up with speed x."
			"    EBx = Fine volume-slide down with speed x."
			"    ECx = Note cut. Set volume to zero after x ticks."
			"    EDx = Note delay. Wait x ticks before triggering key."
			"    EEx = Pattern delay. Add x ticks to current row."
			"    EFx = Invert loop. (Not supported in Micromod)."
			"    Fxx = Set speed 00 to 1F (ticks per row, default 6)."
			"    Fxx = Set tempo 20 to FF (tick length 2.5/xx seconds, default 7D)." "" );
	}
	
	function num_char( chr radix ) {
		var value;
		if &&( >e( chr '0' ) <e( chr '9' ) ) {
			let value = -( chr '0' );
		} else if &&( >e( chr 'A' ) <e( chr 'Z' ) ) {
			let value = -( chr '7' );
		} else if <>( chr '-' ) {
			let value = radix;
		}
		if >e( value radix ) {
			throw $str( "Invalid character '" $asc( chr ) "'." );
		}
		return value;
	}
	
	function parse_key( key_str ) {
		var chr = $chr( key_str 0 ), chr1 = $chr( key_str 1 ), chr2 = $chr( key_str 2 );
		if <( num_char( chr 17 ) 10 ) {
			return +( *( num_char( chr 10 ) 100 ) *( num_char( chr1 10 ) 10 ) num_char( chr2 10 ) );
		} else {
			var key = $unpack( STRING_TO_KEY -( chr 'A' ) );
			if =( chr1 '\#' ) {
				inc key;
			}
			if <>( $chr( KEY_TO_STRING +( *( key 2 ) 5 ) ) chr1 ) {
				throw $str( "Invalid key '" $sub( key_str 0 3 ) "'." );
			}
			return +( key *( num_char( chr2 10 ) 12 ) );
		}
	}
	
	function period_to_key( period ) {
		var key = 0;
		if &&( >e( period $unpack( KEY_TO_PERIOD 72 ) ) <e( period $unpack( KEY_TO_PERIOD 1 ) ) ) {
			while >( $unpack( KEY_TO_PERIOD +( key 12 ) ) period ) {
				let key = +( key 12 );
			}
			while >e( $unpack( KEY_TO_PERIOD +( key 1 ) ) period ) {
				inc key;
			}
			if >e( -( $unpack( KEY_TO_PERIOD key ) period ) -( period $unpack( KEY_TO_PERIOD +( key 1 ) ) ) ) {
				inc key;
			}
		}
		return key;
	}
	
	function fixed_len_string( str len ) {
		while <( $len( str ) len ) {
			let str = $str( str "        " );
		}
		return $sub( str 0 len );
	}
	
	function trim( str ) {
		var offset, end = -( $len( str ) 1 );
		while &&( >e( end 0 ) <( $chr( str, end ) 33 ) ) {
			let end = -( end 1 );
		}
		return $sub( str, offset, +( end 1 ) );
	}
	
	function split( str separators ( list ) list ) {
		var offset, len = $len( str ), end = $stridx( str separators 0 );
		while >e( end 0 ) {
			call list:add( $sub( str offset -( end++ offset ) ) );
			let offset = end;
			let end = ?( <( offset len ) $stridx( str separators offset ) -1 );
		}
		call list:add( $sub( str offset -( len offset ) ) );
		return list;
	}
	
	function u16be( str, idx ) {
		return |( <<( &( $chr( str idx ) 0xFF ) 8 ) &( $chr( str +( idx 1 ) ) 0xFF ) );
	}
	
	struct sample {
		name, volume, fine_tune, loop_start, loop_length, sample_data;
	}
	
	struct note {
		key, instrument, effect, parameter;
		
		function parse( ( note ) this note_str line ) {
			if <>( $len( note_str ) 8 ) {
				throw $str( "Invalid note '" note_str "' on line " line " (incorrect length)." );
			}
			try {
				let this.key = parse_key( note_str );
				let this.instrument = +( *( num_char( $chr( note_str 3 ) 10 ) 10 ) num_char( $chr( note_str 4 ) 10 ) );
				let this.effect = num_char( $chr( note_str 5 ) 16 );
				let this.parameter = +( <<( num_char( $chr( note_str 6 ) 16 ) 4 ) num_char( $chr( note_str 7 ) 16 ) );
			} catch e {
				throw $str( "Unable to parse note '" note_str "' on line " line ". " e );
			}
		}
		
		function to_string( ( note ) this ) {
			var chars = $buffer( 8  '-' '-' '-' '-' '-' '-' '-' '-' );
			var key = +( this.key 2 );
			if &&( >( key 2 ) <( key 120 ) ) {
				var idx = *( %( key 12 ) 2 );
				let [ chars 0 ] = $chr( KEY_TO_STRING idx++ );
				let [ chars 1 ] = $chr( KEY_TO_STRING idx );
				let [ chars 2 ] = +( '0' _/( key 12 ) );
			}
			var instrument = this.instrument;
			if &&( >( instrument 0 ) <( instrument 100 ) ) {
				if >( instrument 9 ) {
					let [ chars 3 ] = +( '0' _/( instrument 10 ) );
				}
				let [ chars 4 ] = +( '0' %( instrument 10 ) );
			}
			var effect = this.effect, parameter = this.parameter;
			if ||( >( effect 0 ) >( parameter 0 ) ) {
				if <( effect 16 ) {
					let [ chars 5 ] = $chr( HEX_TO_STRING effect );
				}
				let [ chars 6 ] = $chr( HEX_TO_STRING &( >>( parameter 4 ) 0xF ) );
				let [ chars 7 ] = $chr( HEX_TO_STRING &( parameter 0xF ) );
			}
			return $sub( chars 0 8 );
		}
		
		function load( ( note ) this buffer idx ) {
			var in = [ buffer idx ];
			let this.key = &( >>( in 24 ) 0xFF );
			let this.instrument = &( >>( in 16 ) 0xFF );
			let this.effect = &( >>( in 8 ) 0xFF );
			let this.parameter = &( in 0xFF );
		}
		
		function store( ( note ) this buffer idx ) {
			let [ buffer idx ] = |( <<( &( this.key 0xFF ) 24 )
				<<( &( this.instrument 0xFF ) 16 ) <<( &( this.effect 0xFF ) 8 ) &( this.parameter 0xFF ) );
		}
		
		function pack( ( note ) this buffer idx ) {
			var period, instrument = this.instrument, effect = this.effect, parameter = this.parameter, key = this.key;
			if &&( >( key 0 ) <( key 73 ) ) {
				let period = $unpack( KEY_TO_PERIOD key );
			}
			if ||( <( instrument 0 ) >( instrument 31 ) ) {
				let instrument = 0;
			}
			var out = |( &( parameter 0xFF ) <<( &( effect 0xF ) 8 ) );
			let out = |( out <<( &( instrument 0xF ) 12 ) <<( &( period 0xFFF ) 16 ) );
			let [ buffer idx ] = |( out <<( &( instrument 0x10 ) 24 ) );
		}
		
		function unpack( ( note ) this buffer idx ) {
			var in = [ buffer idx ];
			let this.key = period_to_key( &( >>( in 16 ) 0xFFF ) );
			let this.instrument = |( &( >>( in 24 ) 0x10 ) &( >>( in 12 ) 0xF ) );
			let this.effect = &( >>( in 8 ) 0xF );
			let this.parameter = &( in 0xFF ); 
		}
	}
	
	struct module( element ) {
		song_name, num_channels, seq_length, sequence, patterns, samples, resource_path, macros;
		
		function begin( ( module ) this value ) {
			let this.song_name = $unquote( value );
			return $next( value );
		}
		
		function get_num_patterns( ( module ) this ) {
			var sequence = this.sequence, idx, max;
			while <( idx 128 ) {
				var entry = [ sequence idx++ ];
				if >( entry max ) {
					let max = entry;
				}
			}
			return +( max 1 );
		}
		
		function get_pattern( ( module ) this idx ) {
			var pattern = [ this.patterns idx ];
			if !( pattern ) {
				let pattern = $buffer( *( this.num_channels 64 ) );
				let [ this.patterns idx ] = pattern;
			}
			return pattern;
		}
		
		function pack_pattern( ( module ) this idx ) {
			var input = this:get_pattern( idx ), len = $len( input );
			var ( note ) note = $new( note ), output = $buffer( len );
			let idx = 0;
			while <( idx len ) {
				call note:load( input idx );
				call note:pack( output idx++ );
			}
			return $pack( output );
		}
		
		function read( ( module ) this modfile ) {
			switch $sub( modfile, 1082, 2 ) {
				case "K.", "K!", "T4" {
					let this.num_channels = 4;
				}
				case "HN" {
					let this.num_channels = $int( $sub( modfile, 1080, 1 ) );
				}
				case "CH" {
					let this.num_channels = $int( $sub( modfile, 1080, 2 ) );
				}
				default {
					throw "Not a MOD file.";
				}
			}
			let this.song_name = trim( $sub( modfile, 0, 20 ) );
			let this.seq_length = &( $chr( modfile 950 ) 0x7F );
			var idx;
			while <( idx 128 ) {
				let [ this.sequence idx ] = &( $chr( modfile +( 952 idx++ ) ) 0x7F );
			}
			var ( note ) note = $new( note );
			var offset = 271;
			var pat_idx, count = this:get_num_patterns();
			while <( pat_idx count ) {
				var pattern = this:get_pattern( pat_idx++ ), len = $len( pattern );
				let idx = 0;
				while <( idx len ) {
					let [ pattern idx ] = $unpack( modfile offset++ );
					call note:unpack( pattern idx );
					call note:store( pattern idx++ );
				}
			}
			let offset = *( offset 4 );
			let idx = 1;
			while <( idx 32 ) {
				var ( sample ) sample = [ this.samples idx ];
				let sample.name = trim( $sub( modfile -( *( idx 30 ) 10 ) 22 ) );
				var length = *( u16be( modfile, +( *( idx 30 ) 12 ) ) 2 );
				if >e( +( offset length ) $len( modfile ) ) {
					let length = -( $len( modfile ) offset );
				}
				var fine = &( $chr( modfile +( *( idx 30 ) 14 ) ) 0xF );
				let sample.fine_tune = -( &( fine 0x7 ) &( fine 0x8 ) );
				var vol = &( $chr( modfile +( *( idx 30 ) 15 ) ) 0x7F );
				let sample.volume = ?( >( vol 64 ) 64 vol );
				var loopidx = *( u16be( modfile, +( *( idx 30 ) 16 ) ) 2 );
				var looplen = *( u16be( modfile, +( *( idx 30 ) 18 ) ) 2 );
				if >( +( loopidx looplen ) length ) {
					if <e( +( _/( loopidx 2 ) looplen ) length ) {
						// Some old modules have loop start in bytes.
						let loopidx = _/( loopidx 2 );
					} else {
						let looplen = -( length loopidx );
					}
				}
				if <( looplen 4 ) {
					let loopidx = length;
					let looplen = 0;
				}
				let sample.loop_start = loopidx;
				let sample.loop_length = looplen;
				let sample.sample_data = $sub( modfile offset length );
				let offset = +( offset length );
				inc idx;
			}
		}
		
		function write( ( module ) this ) {
			var ( list ) list = $new( list $buffer( 65536 ) );
			call list:add_string( fixed_len_string( this.song_name 20 ) );
			var idx = 1;
			while <( idx 32 ) {
				var ( sample ) sam = [ this.samples idx++ ];
				call list:add_string( fixed_len_string( sam.name 22 ) );
				call list:add( >>( $len( sam.sample_data ) 9 ) );
				call list:add( >>( $len( sam.sample_data ) 1 ) );
				call list:add( ?( <( sam.fine_tune 0 ) +( sam.fine_tune 16 ) sam.fine_tune ) );
				call list:add( sam.volume );
				call list:add( >>( sam.loop_start 9 ) );
				call list:add( >>( sam.loop_start 1 ) );
				call list:add( >>( sam.loop_length 9 ) );
				call list:add( >>( sam.loop_length 1 ) );
			}
			call list:add( this.seq_length );
			call list:add( 0 );
			call list:add_string( $sub( this.sequence 0 128 ) );
			switch this.num_channels {
				case 4 {
					call list:add_string( "M.K." );
				}
				case 6, 8 {
					call list:add( +( '0' this.num_channels ) );
					call list:add_string( "CHN" );
				}
				default {
					call list:add( '1' );
					call list:add( +( '0' -( this.num_channels 10 ) ) );
					call list:add_string( "CH" );
				}
			}
			let idx = 0;
			var len = this:get_num_patterns();
			while <( idx len ) {
				call list:add_string( this:pack_pattern( idx++ ) );
			}
			let idx = 1;
			while <( idx 32 ) {
				call list:add_string( sample.sample_data( [ this.samples idx++ ] ) );
			}
			return $sub( list.array 0 list.len );
		}
		
		function decompile( ( module ) this write_sample_data ) {
			var ( list ) list = $new( list $buffer( 65536 ) );
			call list:add_string( "Module ");
			call list:add_string( $quote( this.song_name ) );
			call list:add( '\n' );
			call list:add_string( "Channels ");
			call list:add_string( $str( this.num_channels ) );
			call list:add( '\n' );
			call list:add_string( "Sequence \"");
			var sequence = this.sequence, idx, len = this.seq_length;
			call list:add_string( $str( [ sequence idx++ ] ) ); 
			while <( idx len ) {
				call list:add_string( $str( "," [ sequence idx++ ] ) );
			}
			call list:add_string( "\"\n" );
			let idx = 1;
			while <( idx 32 ) {
				var ( sample ) sample = [ this.samples idx ];
				var sample_data = sample.sample_data;
				if ||( $len( sample.name ) $len( sample_data ) ) {
					call list:add_string( "\tInstrument ");
					call list:add_string( $str( idx ) );
					if $len( sample.name ) {
						call list:add_string( " Name ");
						call list:add_string( $quote( sample.name ) );
					}
					if sample.volume {
						call list:add_string( " Volume ");
						call list:add_string( $str( sample.volume ) );
					}
					if sample.fine_tune {
						call list:add_string( " FineTune ");
						call list:add_string( $str( sample.fine_tune ) );
					}
					if $len( sample_data ) {
						var file_name = $str( ?( <( idx 10 ) "0" "" ) idx ".raw" );
						call list:add_string( " WaveFile \"" );
						call list:add_string( file_name );
						call list:add( '\"' );
						if write_sample_data {
							call :( write_sample_data file_name sample_data );
						}
						call list:add_string( " LoopStart ");
						call list:add_string( $str( sample.loop_start ) );
						call list:add_string( " LoopLength ");
						call list:add_string( $str( sample.loop_length ) );
					}
					call list:add( '\n' );
				}
				inc idx;
			}
			var ( note ) note = $new( note ), num_channels = this.num_channels;
			let idx = 0, len = this:get_num_patterns();
			while <( idx len ) {
				call list:add_string( "\tPattern ");
				call list:add_string( $str( idx ) );
				call list:add( '\n' );
				var pattern = this:get_pattern( idx++ );
				var row = 0, offset = 0;
				while <( row 64 ) {
					call list:add_string( "\t\tRow \"" );
					if <( row 10 ) {
						call list:add( '0' );
					}
					call list:add_string( $str( row++ ) );
					var end = +( offset num_channels );
					while <( offset end ) {
						call list:add( 32 );
						call note:load( pattern offset++ );
						call list:add_string( note:to_string() );
					}
					call list:add_string( "\"\n" );
				}
			}
			return $sub( list.array 0 list.len );
		}
	}
	
	function new_module( resource_path ) {
		var ( module ) this = $new( module "Module"
			$array( 1 "\"Title\" (Song title, maximum 20 characters.)" ) NULL NULL NULL @module_begin NULL
			"Untitled" 4 1 $buffer( 128 ) $array( 128 ) $array( 32 ) resource_path $array( 100 ) );
		let this.child = new_channels( this );
		var samples = this.samples, idx;
		while <( idx 32 ) {
			let [ samples idx++ ] = $new( sample "" 0 0 0 0 $buffer( 0 ) );
		}
		return this;
	}
	
	struct channels( element ) {
		;
		function begin( ( channels ) this value ) {
			var num_channels = check_range( $int( value ) 4 16 "num channels" $line( value ) );
			let module.num_channels( this.parent ) = +( num_channels &( num_channels 1 ) );
			return $next( value );
		}
	}
	
	function new_channels( module ) {
		return $new( channels "Channels"
			$array( 1 "4 (Number of channels. Four channel modules have fixed panning.)" )
			module new_sequence( module ) NULL @channels_begin );
	}
	
	struct sequence( element ) {
		;
		function begin( ( sequence ) this value ) {
			var ( list ) list = $new( list $buffer( 128 ) );
			var next = parse_integers( value list );
			var idx, arr = list.array, len = list.len;
			let module.seq_length( this.parent ) = check_range( len 1 127 "sequence length" $line( value ) );
			while <( idx len ) {
				call check_range( [ arr idx++ ] 0 127 "sequence pattern index" $line( value ) );
			}
			let module.sequence( this.parent ) = arr;
			return next;
		}
	}
	
	function new_sequence( module ) {
		return $new( sequence "Sequence"
			$array( 1 "0,1,2,... (The order in which patterns are played in the song.)" )
			module new_instrument( module ) NULL @sequence_begin );
	}
	
	struct instrument( waveform_parent ) {
		index, sample, ping_pong;
		
		function begin( ( instrument ) this value ) {
			let this.index = check_range( parse_integer( value ) 1 31 "instrument index" $line( value ) );
			var ( sample ) sample = [ module.samples( this.parent ) this.index ];
			let sample.name = "", sample.volume = 0, sample.fine_tune = 0;
			let sample.loop_start = 0, sample.loop_length = 0x1FFFE;
			let this.sample = sample;
			let this.ping_pong = FALSE;
			let this.audiodata = NULL;
			return $next( value );
		}
		
		function end( ( instrument ) this ) {
			var ( audiodata_waveform ) waveform = this.audiodata;
			var ( sample ) sample = this.sample, loop_start, loop_length;
			if waveform {
				var sample_length = waveform:get_num_samples();
				let loop_start = sample.loop_start, loop_length = sample.loop_length;
				let loop_start = &( loop_start -2 ), loop_length = &( loop_length -2 );
				if >( +( loop_start loop_length ) sample_length ) {
					let loop_length = &( -( sample_length loop_start ) -2 );
				}
				if ||( <( loop_start 0 ) >e( loop_start sample_length ) <( loop_length 4 ) ) {
					let loop_start = &( sample_length -2 );
					let loop_length = 0;
				}
				let sample_length = +( loop_start *( loop_length ?( this.ping_pong 2 1 ) ) );
				if >( sample_length 0x1FFFE ) {
					throw $str( "Instrument " this.index " sample data length out of range (" sample_length ", max 131070)." );
				}
				let waveform = waveform:copy_channel( 0 0
					audiodata_new_waveform( 1 waveform.sample_rate $buffer( sample_length ) ) 0 0 +( loop_start loop_length ) );
				if this.ping_pong {
					let loop_length = *( loop_length 2 );
					var sample_data = waveform.sample_data, idx = loop_start, end = -( sample_length 1 );
					while <( idx end ) {
						let [ sample_data end-- ] = [ sample_data idx++ ];
					}
				}
				let sample.sample_data = waveform:quantize( 0 );
			}
			let sample.loop_start = loop_start, sample.loop_length = loop_length;
		}
	}
	
	function new_instrument( module ) {
		var ( instrument ) this = $new( instrument "Instrument"
			$array( 1 "Index (Instrument index, from 1 to 31.)" )
			module new_macro( module ) NULL @instrument_begin @instrument_end );
		let this.child = new_name( this );
		return this;
	}
	
	struct name( element ) {
		;
		function begin( ( name ) this value ) {
			let sample.name( instrument.sample( this.parent ) ) = $unquote( value );
			return $next( value );
		}
	}
	
	function new_name( instrument ) {
		return $new( name "Name"
			$array( 1 "\"Name\" (Instrument name, maximum 22 characters.)" )
			instrument new_volume( instrument ) NULL @name_begin );
	}
	
	struct volume( element ) {
		;
		function begin( ( volume ) this value ) {
			var volume = check_range( parse_integer( value ) 0 64 "instrument volume" $line( value ) );
			let sample.volume( instrument.sample( this.parent ) ) = volume;
			return $next( value );
		}
	}
	
	function new_volume( instrument ) {
		return $new( volume "Volume"
			$array( 1 "0 (Instrument volume, 0 to 64.)" )
			instrument new_finetune( instrument ) NULL @volume_begin );
	}
	
	struct finetune( element ) {
		;
		function begin( ( finetune ) this value ) {
			var finetune = check_range( $int( value ) -7 8 "instrument finetune" $line( value ) );
			let sample.fine_tune( instrument.sample( this.parent ) ) = finetune;
			return $next( value );
		}
	}
	
	function new_finetune( instrument ) {
		return $new( finetune "FineTune"
			$array( 1 "0 (Fine-tuning in eighths of a semitone, from -8 to 7.)" )
			instrument new_waveform( instrument new_wavefile( instrument ) ) NULL @finetune_begin );
	}
	
	struct wavefile( element ) {
		file, offset, count, divisions, gain, pitch;
		
		function begin( ( wavefile ) this value ) {
			let this.file = $str( module.resource_path( instrument.parent( this.parent ) ) $unquote( value ) );
			let this.offset = 0, this.count = 0, this.divisions = 0, this.gain = 64, this.pitch = 0;
			var ( sample ) sample = instrument.sample( this.parent );
			let sample.loop_start = 0, sample.loop_length = 0;
			return $next( value );
		}
		
		function end( ( wavefile ) this ) {
			var ( audiodata_waveform ) waveform, data;
			try {
				let data = $load( this.file );
			} catch e {
				throw $str( "Unable to load '" this.file "'. " e );
			}
			var idx = +( $endidx( this.file "." ) 1 ), len;
			switch $sub( this.file idx -( $len( this.file ) idx ) ) {
				case "WAV" "wav" {
					let waveform = audiodata_wav_waveform( data );
				}
				case "IFF" "iff" {
					let waveform = audiodata_iff_waveform( data );
				}
				default {
					let len = $len( data );
					if >( len 131070 ) {
						let len = 131070;
					}
					let waveform = audiodata_raw_waveform( 8000 data 0 len );
				}
			}
			if >( this.count 0 ) {
				let len = 1;
				if >( this.divisions 1 ) {
					let len = _/( waveform:get_num_samples() this.divisions );
				}
				let waveform = waveform:crop( *( this.offset len ) *( this.count len ) );
			}
			if <>( this.gain 64 ) {
				let waveform = waveform:amplify( <<( this.gain -( audiodata_FP_SHIFT 6 ) ) );
			}
			if <>( this.pitch 0 ) {
				var rate = waveform.sample_rate;
				call waveform:adjust_pitch( _/( <<( this.pitch audiodata_FP_SHIFT ) 96 ) );
				let waveform = waveform:resample_channel( 0 rate );
			}
			let instrument.audiodata( this.parent ) = waveform;
		}
	}
	
	function new_wavefile( instrument ) {
		var ( wavefile ) this = $new( wavefile "WaveFile"
			$array( 1 "\"FileName\" (The relative path of the WAV file.)" )
			instrument new_loopstart( instrument ) NULL @wavefile_begin @wavefile_end );
		let this.child = new_crop( this );
		return this;
	}
	
	struct crop( element ) {
		;
		function begin( ( crop ) this value ) {
			var ( list ) list = $new( list $buffer( 3 ) );
			var next = parse_integers( value list );
			if <( check_range( list.len 1 3 "number of crop parameters" $line( value ) ) 2 ) {
				let wavefile.count( this.parent ) = [ list.array 0 ];
			} else {
				let wavefile.offset( this.parent ) = [ list.array 0 ];
				let wavefile.count( this.parent ) = [ list.array 1 ];
				let wavefile.divisions( this.parent ) = [ list.array 2 ];
			}
			return next;
		}
	}
	
	function new_crop( wavefile ) {
		return $new( crop "Crop"
			$array( 3 "\"Offset,Count[,Divisions]\" (Crop Count Divisions from Offset.)"
				"(The Divisions parameter divides the sample into segments.)"
				"(If unspecified, one division is equivalent to one sample.)" )
			wavefile new_gain( wavefile ) NULL @crop_begin );
	}
	
	struct gain( element ) {
		;
		function begin( ( gain ) this value ) {
			let wavefile.gain( this.parent ) = parse_integer( value );
			return $next( value );
		}
	}
	
	function new_gain( wavefile ) {
		return $new( gain "Gain"
			$array( 1 "64 (Amplification factor, divided by 64.)" )
			wavefile new_pitch( wavefile ) NULL @gain_begin );
	}
	
	struct pitch( element ) {
		;
		function begin( ( pitch ) this value ) {
			let wavefile.pitch( this.parent ) = parse_integer( value );
			return $next( value );
		}
	}
	
	function new_pitch( wavefile ) {
		return $new( pitch "Pitch"
			$array( 1 "0 (Tune the sample in eighths of a semitone.)" )
			wavefile NULL NULL @pitch_begin );
	}
	
	struct loopstart( element ) {
		;
		function begin( ( loopstart ) this value ) {
			let sample.loop_start( instrument.sample( this.parent ) ) = parse_integer( value );
			return $next( value );
		}
	}
	
	function new_loopstart( instrument ) {
		return $new( loopstart "LoopStart"
			$array( 1 "Offset (Offset of sustain phase in samples.)" )
			instrument new_looplength( instrument ) NULL @loopstart_begin );
	}
	
	struct looplength( element ) {
		;
		function begin( ( looplength ) this value ) {
			let sample.loop_length( instrument.sample( this.parent ) ) = parse_integer( value );
			return $next( value );
		}
	}
	
	function new_looplength( instrument ) {
		return $new( looplength "LoopLength"
			$array( 1 "Length (Length of sustain phase in samples.)" )
			instrument new_pingpong( instrument ) NULL @looplength_begin );
	}
	
	struct pingpong( element ) {
		;
		function begin( ( pingpong ) this value ) {
			switch value {
				case "On" { let instrument.ping_pong( this.parent ) = TRUE; }
				case "Off" { let instrument.ping_pong( this.parent ) = FALSE; }
				default { throw $cat( "Invalid PingPong parameter (On or Off) on line " $line( value ) "." ); }
			}
			return $next( value );
		}
	}
	
	function new_pingpong( instrument ) {
		return $new( pingpong "PingPong"
			$array( 1 "Off (Set to On to append a reversed sustain phase to the sample.)" )
			instrument NULL NULL @pingpong_begin );
	}
	
	struct macro( element ) {
		index, notes, row, repeat_row, scale, root;
		
		function begin( ( macro ) this value ) {
			let this.index = check_range( parse_integer( value ) 1 99 "macro index" $line( value ) );
			let this.notes = $buffer( *( 64 4 ) ), this.row = 0, this.repeat_row = 0;
			throw "Macro not supported.";
		}
	}
	
	function new_macro( module ) {
		return $new( macro "Macro"
			$array( 1 "Index (Macro index, from 1 to 99.)" )
			module new_pattern( module ) NULL @macro_begin );
	}
	
	struct pattern( element ) {
		index;
		
		function begin( ( pattern ) this value ) {
			let this.index = check_range( parse_integer( value ) 0 127 "pattern index" $line( value ) );
			let row.index( this.child ) = 0;
			return $next( value );
		}
	}
	
	function new_pattern( module ) {
		var ( pattern ) this = $new( pattern "Pattern"
			$array( 1 "Index (Pattern index, from 0 to 127.)" )
			module NULL NULL @pattern_begin );
		let this.child = new_row( this );
		return this;
	}
	
	struct row( element ) {
		index;
		
		function begin( ( row ) this value ) {
			var line = $line( value ), offset;
			var ( module ) module = pattern.parent( this.parent ), ( note ) note = $new( note );
			var pattern = module:get_pattern( pattern.index( this.parent ) ), row_idx, channel;
			var ( list ) list = split( $unquote( value ) " " $new( list $array( 32 ) ) );
			var arr = list.array, len = list.len, idx;
			if <( len 1 ) {
				throw $str( "Invalid row on line " line "." );
			}
			var str = [ arr idx++ ];
			try {
				while <( offset $len( str ) ) {
					let row_idx = +( *( row_idx 10 ) $int( $sub( str offset++ 1 ) ) );
				}
			} catch e {
				throw $str( "Invalid row index '" str "' on line " line ". " e );
			}
			call check_range( row_idx 0 63 "row index" line );
			if <( row_idx this.index ) {
				throw $str( "Row index " row_idx " is less than previous on line " line "." );
			}
			let this.index = row_idx;
			let offset = *( row_idx module.num_channels );
			while <( idx len ) {
				let str = [ arr idx++ ];
				if $len( str ) {
					call note:parse( str line );
					call note:store( pattern offset++ );
				}
			}
			return $next( value );
		}
	}
	
	function new_row( pattern ) {
		return $new( row "Row"
			$array( 3 "\"00 C-2-1--- -------- ...\" (Specify a single row within a pattern.)"
				"(Row index, from 0 to 63, followed by notes for each channel.)"
				"(See the '-notes' command-line option for more information.)" )
			pattern NULL NULL @row_begin );
	}
}

program compiler {
	var ( module ) module;
	var idx = 1, mt_file, mod_file, output, syntax, notes;
	while <( idx $argc ) {
		switch $argv( idx++ ) {
			case "-mt" {
				let mt_file = $argv( idx++ );
			}
			case "-mod" {
				let mod_file = $argv( idx++ );
			}
			case "-out" {
				let output = $argv( idx++ );
			}
			case "-syntax" {
				let syntax = TRUE;
			}
			case "-notes" {
				let notes = TRUE;
			}
		}
	}
	if syntax {
		print element_syntax( new_module( "" ) );
	} else if notes {
		var info = note_info();
		let idx = 0;
		while <( idx $len( info ) ) {
			var line = [ info idx++ ];
			if line {
				print line;
			}
		}
	} else if &&( mt_file output ) {
		print $str( "Compiling '" mt_file "' to '" output "'."  );
		let module = new_module( $sub( mt_file 0 +( $endidx( mt_file "/\\" ) 1 ) ) );
		call parse( $load( mt_file ) module );
		save module:write() output;
	} else if &&( mod_file output ) {
		print $str( "Decompiling '" mod_file "' to '" output "'."  );
		let module = new_module( $sub( output 0 +( $endidx( output "/\\" ) 1 ) ) );
		call module:read( $load( mod_file ) );
		save module:decompile( $function( ${ ( name data ) { save data $str( module.resource_path name ); } } ) ) output;
	} else {
		error $str( "Micromod Compiler! " VERSION );
		error "          Compile: -mt input.mt -out output.mod";
		error "        Decompile: -mod input.mod -out output.mt";
		error "  Print MT Syntax: -syntax";
		error "  Print Note Info: -notes";
	}
}
