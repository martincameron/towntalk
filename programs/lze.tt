
/*{
	Simplified LZ77 compression using single-entry lookup table.
}*/

//# Return the encoded length and encode to output if not null.
function lze_encode( input, output ) {
	var hash = $buffer( 65536 ), code, in_idx, in_len = $len( input ), in_end = -( in_len 8 ), out_idx, lit, off, len;	
	while <e( in_idx in_end ) {
		if <( in_idx in_end ) {
			let len = 1;
			let code = ^( <<( &( $chr( input in_idx ) 0xFF ) 8 ) <<( &( $chr( input +( in_idx 3 ) ) 0xFF ) 4 ) &( $chr( input +( in_idx 6 ) ) 0xFF ) );
			let off = -( in_idx [ hash code ] );
			set [ hash code ] = in_idx;
			if &&( off <( off 65536 ) =( $chr( input -( in_idx off ) ) $chr( input in_idx ) ) ) {
				while &&( <( +( in_idx len ) in_end ) =( $chr( input +( -( in_idx off ) len ) ) $chr( input +( in_idx len ) ) ) ) {
					inc len;
				}
			}
		} else {
			let off = 0, len = 8, lit = +( lit 8 ), in_idx = in_len;
		}
		if >( len 3 ) {
			while >( lit 0 ) {
				var count = lit;
				if >( count 127 ) {
					let count = 127;
				}
				let lit = -( lit count );
				if output {
					set [ output out_idx++ ] = count;
					var end = -( in_idx lit ), idx = -( end count );
					while <( idx end ) {
						set [ output out_idx++ ] = $chr( input idx++ );
					}
				} else {
					let out_idx = +( out_idx +( 1 count ) );
				}
			}
			if >( off 0 ) {
				if >( len 127 ) {
					let len = 127;
				}
				if output {
					set [ output out_idx++ ] = |( 0x80 len );
					set [ output out_idx++ ] = >>( off 8 );
					set [ output out_idx++ ] = &( off 0xFF );
				} else {
					let out_idx = +( out_idx 3 );
				}
			}
			let in_idx = +( in_idx len );
		} else {
			inc in_idx;
			inc lit;
		}
	}
	return out_idx;
}

//# Return the decoded length and decode to output if not null.
function lze_decode( input, output ) {
	var in_idx, in_end = $len( input ), out_idx, len, off, end;
	if output {
		while <( in_idx in_end ) {
			let len = $chr( input in_idx++ );
			if <( len 0 ) {
				let off = |( <<( &( $chr( input in_idx++ ) 0xFF ) 8 ) &( $chr( input in_idx++ ) 0xFF ) );
				let end = +( out_idx &( len 0x7F ) );
				while <( out_idx end ) {
					set [ output out_idx ] = [ output -( out_idx++ off ) ];
				}
			} else {
				let end = +( out_idx len );
				while <( out_idx end ) {
					set [ output out_idx++ ] = $chr( input in_idx++ );
				}
			}
		}
	} else {
		while <( in_idx in_end ) {
			let len = $chr( input in_idx++ );
			if <( len 0 ) {
				let in_idx = +( in_idx 2 );
				let out_idx = +( out_idx &( len 0x7F ) );
			} else {
				let in_idx = +( in_idx len );
				let out_idx = +( out_idx len );
			}
		}
	}
	return out_idx;
}

program lze {
	var org, buf, enc, out;
	if =( $argc 3 ) {
		let org = $load( $argv( 1 ) );
		print $cat( "Original length: " $len( org ) );
		
		let buf = $buffer( lze_encode( org 0 ) );
		print $cat( "Compressed length: " lze_encode( org buf ) );
		let enc = $sub( buf 0 $len( buf ) );
		
		let buf = $buffer( lze_decode( enc 0 ) );
		print $cat( "Decompressed length: " lze_decode( enc buf ) );
		let out = $sub( buf 0 $len( buf ) );

		if $cmp( org out ) {
			throw "Decoded data differs from original!";
		}
		save enc $argv( 2 );
	} else {
		error "LZ77 compression.";
		error "Usage lze.tt input output.lze";
	}
}
