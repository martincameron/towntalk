
library util {
	//# Constants for type expression.
	const TYPE_STRING = $type( "" ),
		TYPE_ELEMENT = $type( ${-} ),
		TYPE_ARRAY = $type( $array( 0 ) ),
		TYPE_FUNCTION = $type( $function( ${ (){} } ) );

	//# Marker struct for string functions.
	struct string {
	}

	//# Marker struct for array functions.
	struct array {
	}

	//# Array-backed list.
	struct list {
		array, len
	}

	//# Simple hash-map with string keys.
	struct map {
		entries
	}

	//# Map entry.
	struct entry {
		key value
	}

	//# Return a new list with an initial capacity of 8.
	function new_list() {
		return $new( list $array( 8 ) );
	}

	//# Increase the capacity of the specified list by the specified amount and return the new backing-array.
	function list_expand( ( list ) this, amount ) {
		var idx, old = this.array, len = this.len, arr = $array( +( $len( old ) amount ) );
		while <( idx len ) {
			let [ arr idx ] = [ old idx++ ];
		}
		let this.array = arr;
		return arr;
	}

	//# Add the specified value to the end of the list.
	function list_add( ( list ) this, value ) {
		var arr = this.array, len = this.len;
		if >e( len $len( arr ) ) {
			let arr = this:expand( +( len 1 ) );
		}
		let [ arr len++ ] = value;
		let this.len = len;
	}

	//# Add the specified range from the specified array to the specified list.
	function list_add_array( ( list ) this, arr, offset, len ) {
		var dest = this.array, idx = this.len, end = +( idx len );
		if >( end $len( dest ) ) {
			let dest = this:expand( end );
		}
		while <( idx end ) {
			let [ dest idx++ ] = [ arr offset++ ];
		}
		let this.len = end;
	}

	//# Add the specified characters from the specified string to the specified list.
	function list_add_chars( ( list ) this, str, offset, len ) {
		var dest = this.array, idx = this.len, end = +( idx len );
		if >( end $len( dest ) ) {
			let dest = this:expand( end );
		}
		while <( idx end ) {
			let [ dest idx++ ] = &( $chr( str offset++ ) 0xFF );
		}
		let this.len = end;
	}

	//# Insert the specified value into the specified list at the specified index.
	function list_insert( ( list ) this, value, index ) {
		call list_add( this, value );
		var arr = this.array, len = this.len;
		while <( index len ) {
			var tmp = [ arr index ];
			let [ arr index++ ] = value;
			let value = tmp;
		}
	}

	//# Remove the value at the specified index from the specified list.
	function list_remove( ( list ) this, index ) {
		var arr = this.array, len = this.len, offset = index, value = [ arr index++ ];
		while <( index len ) {
			let [ arr offset++ ] = [ arr index++ ];
		}
		let this.len = -( len 1 );
		return value;
	}

	//# Call the specified function once for each item in the list.
	function list_for_each( ( list ) this, func ) {
		var arr = this.array, len = this.len, idx;
		while <( idx len ) {
			call :( func [ arr idx++ ] );
		}
	}

	//# Find the entry instance with the specified key in the list.
	function list_find_entry( ( list ) this, key ) {
		var arr = this.array, len = this.len, idx;
		while <( idx len ) {
			var ( entry ) entry = [ arr idx++ ];
			if $eq( key entry.key ) {
				return entry;
			}
		}
		return NULL;
	}

	//# Remove the entry with the specified key from the list if present.
	function list_remove_entry( ( list ) this, key ) {
		var arr = this.array, end = -( this.len 1 ), idx;
		while <e( idx end ) {
			var ( entry ) entry = [ arr idx++ ];
			if $eq( key entry.key ) {
				let [ arr -( idx 1 ) ] = [ arr end ];
				let this.len = end;
				return entry;
			}
		}
	}

	//# Create a new hash-map.
	function new_map() {
		var entries = $array( 32 ), idx;
		while <( idx 32 ) {
			let [ entries idx++ ] = new_list();
		}
		return $new( map entries );
	}

	//# Calculate a 5-bit hash-code for the specified string.
	function hash_code( str ) {
		var hash, len = $len( str ), idx;
		while <( idx len ) {
			let hash = ^( hash $chr( str idx++ ) );
		}
		return &( hash 0x1F );
	}

	//# Return the map entry for the specified key, or NULL.
	function map_get_entry( ( map ) this, key ) {
		return list_find_entry( [ this.entries hash_code( key ) ] key );
	}

	//# Return the value for the specified key, or NULL.
	function map_get( ( map ) this, key ) {
		var ( entry ) entry = this:get_entry( key );
		if entry {
			return entry.value;
		}
		return NULL;
	}

	//# Remove the specified entry from the map, if present.
	function map_remove( ( map ) this, key ) {
		return list_remove_entry( [ this.entries hash_code( key ) ], key );
	}

	//# Put the specified value into the map under the specified string key.
	function map_put( ( map ) this, key, value ) {
		var hash = hash_code( key );
		var ( list ) list = [ this.entries hash ];
		var ( entry ) entry = list:find_entry( key );
		if entry {
			let entry.value = value;
		} else {
			call list:add( $new( entry! key value ) );
		}
	}

	//# Call the specified function once for each entry instance in the map.
	function map_for_each( ( map ) this, func ) {
		var entries = this.entries, len = $len( entries ), idx;
		while <( idx len ) {
			call list_for_each( [ entries idx++ ], func );
		}
	}

	//# Call the specified function once for each value in the array.
	function array_for_each( arr, func ) {
		var idx, len = $len( arr );
		while <( idx len ) {
			call :( func [ arr idx++ ] );
		}
	}

	//# Return a new list instance backed by the specified array.
	function array_as_list( arr ) {
		return $new( list arr $len( arr ) );
	}

	//# Return a new array instance containing the specified range.
	function array_slice( arr, offset, len ) {
		var slice = $array( len ), idx;
		while <( offset len ) {
			let [ slice idx++ ] = [ arr offset++ ];
		}
		return slice;
	}

	//# Copy the specified range from the source array to the dest array.
	function array_copy( src src_offset dest dest_offset len ) {
		var src_end = +( src_offset len );
		var dest_end = +( dest_offset len );
		if <( src_end dest_end ) {
			dec src_end;
			dec dest_end;
			while >e( src_end src_offset ) {
				let [ dest dest_end-- ] = [ src src_end-- ];
			}
		} else {
			while <( src_offset src_end ) {
				let [ dest dest_offset++ ] = [ src src_offset++ ];
			}
		}
	}

	//# Return the content of the specified string with leading and trailing spaces removed.
	function string_trim( this ) {
		var idx, end = -( $len( this ) 1 );
		while <e( idx end ) {
			if >( $chr( this idx++ ) 32 ) {
				dec idx;
				while >e( end idx ) {
					if >( $chr( this end-- ) 32 ) {
						return $sub( this idx -( end idx -2 ) );
					}
				}
			}
		}
		return "";
	}

	//# Add the specified value to the specified characters in the array within the specified range.
	//# The returned value will be over 127 if the string contains non-ASCII characters.
	function array_shift_case( this offset len start end add ) {
		var bits;
		while <( offset len ) {
			var chr = [ this offset ];
			if >e( chr start ) {
				if <e( chr end ) {
					let chr = +( chr add );
				}
			}
			let [ this offset++ ] = chr;
			let bits = |( bits chr );
		}
		return bits;
	}

	//# Upper-case the specified latin characters within the specified array.
	function array_upper( ( array ) this len ) {
		var bits = this:shift_case( 0 len 97 122 -32 );
		if &( bits 0x80 ) {
			call this:shift_case( 0 len 224 246 -32 );
			call this:shift_case( 0 len 248 255 -32 );
		}
		return bits;
	}

	//# Lower-case the specified latin characters within the specified array.
	function array_lower( ( array ) this len ) {
		var bits = this:shift_case( 0 len 65 90 32 );
		if &( bits 0x80 ) {
			call this:shift_case( 0 len 192 214 32 );
			call this:shift_case( 0 len 216 223 32 );
		}
		return bits;
	}

	//# Copy the specified unsigned characters from the specified string into the specified array.
	function string_get_chars( this offset array index len ) {
		var end = +( offset len );
		while <( offset end ) {
			let [ array index++ ] = &( $chr( this offset++ ) 0xFF );
		}
	}

	//# Return an upper-case representation of the specified ASCII string.
	function string_upper( ( string ) this ) {
		var len = $len( this ), ( array ) arr = $buffer( len );
		call this:get_chars( 0 arr 0 len );
		call arr:shift_case( 0 len 97 122 -32 );
		return $sub( arr 0 len );
	}

	//# Return an upper-case representation of the specified ASCII or ISO-8859-1 encoded string.
	function string_upper_latin( ( string ) this ) {
		var len = $len( this ), ( array ) arr = $buffer( len );
		call this:get_chars( 0 arr 0 len );
		call arr:upper( len );
		return $sub( arr 0 len );
	}

	//# Return a lower-case representation of the specified ASCII string.
	function string_lower( ( string ) this ) {
		var len = $len( this ), ( array ) arr = $buffer( len );
		call this:get_chars( 0 arr 0 len );
		call arr:shift_case( 0 len 65 90 32 );
		return $sub( arr 0 len );
	}

	//# Return a lower-case representation of the specified ASCII or ISO-8859-1 encoded string.
	function string_lower_latin( ( string ) this ) {
		var len = $len( this ), ( array ) arr = $buffer( len );
		call this:get_chars( 0 arr 0 len );
		call arr:lower( len );
		return $sub( arr 0 len );
	}

	//# Return a list instance containing the text between the specified separator characters.
	function string_split( this, separators ) {
		var ( list ) list = new_list();
		var offset, len = $len( this ), end = $stridx( this separators 0 );
		while >e( end 0 ) {
			call list:add( $sub( this offset -( end++ offset ) ) );
			let offset = end;
			let end = ?( <( offset len ) $stridx( this separators offset ) -1 );
		}
		call list:add( $sub( this offset -( len offset ) ) );
		return list;
	}

	//# Return the first index of the specified substring within the specified string, or -1.
	function string_find( this, substr, offset ) {
		var sublen = $len( substr ), strend = -( $len( this ) sublen ), firstchr = $sub( substr 0 1 );
		while <e( offset strend ) {
			var idx = $stridx( this firstchr offset );
			if ||( <( idx 0 ) >( idx strend ) ) {
				return -1;
			}
			var end = +( idx++ sublen ), subidx = 1;
			let offset = idx;
			while &&( <( idx end ) =( $chr( this idx ) $chr( substr subidx ) ) ) {
				inc subidx;
				inc idx;
			}
			if >e( idx end ) {
				return -( idx sublen );
			}
		}
		return -1;
	}

	//# Return a copy of this string with the specified string value inserted at the specified index.
	function string_insert( this, value, index ) {
		return $str( $sub( this 0 index ) value $sub( this index -( $len( this ) index ) ) );
	}

	//# Decode the specified UTF-8 encoded string into the specified array.
	//# The array should be the same length as the string to prevent overflow.
	//# The number of characters decoded is returned.
	function string_utf8_decode( this, array ) {
		var offset, len = $len( this ), count;
		while <( offset len ) {
			var chr = $chr( this offset++ );
			if <( chr 0 ) {
				if &( chr 0x40 ) {
					var shift = 6, mask = 0x1F;
					if &( chr 0x20 ) {
						let shift = 12, mask = 0xF;
						if &( chr 0x10 ) {
							let shift = 18, mask = 0x7;
						}
					}
					let chr = <<( &( chr mask ) shift );
					while shift {
						let shift = -( shift 6 );
						let chr = |( chr <<( &( $chr( this offset++ ) 0x3F ) shift ) );
					}
				}
				if <( chr 128 ) {
					throw $str( "Invalid UTF-8 encoding at offset " -( offset 1 ) );
				}
			}
			let [ array count++ ] = chr;
		}
		return count;
	}

	//# Return a UTF-8 encoded string containing the characters in the specified array.
	function array_utf8_encode( this, offset, len ) {
		var start = offset, ( list ) list = $new( list $buffer( *( len 2 ) ) );
		while <( offset len ) {
			var chr = [ this offset++ ];
			if >( chr 127 ) {
				call list:add_array( this start -( offset start 1 ) );
				var shift = 6, prefix = 0xC0;
				if >( chr 0x7FF ) {
					let shift = 12, prefix = 0xE0;
					if >( chr 0xFFFF ) {
						let shift = 18, prefix = 0xF0;
					}
				}
				call list:add( |( prefix &( >>( chr shift ) 0x3F ) ) );
				while shift {
					let shift = -( shift 6 );
					call list:add( |( 0x80 &( >>( chr shift ) 0x3F ) ) );
				}
				let start = offset;
			}
		}
		if start {
			if <( start len ) {
				call list:add_array( this start -( len start ) );
			}
			return $sub( list.array 0 list.len );
		}
		return $sub( this offset len );
	}

	//# Encode the specified ISO-8859-1 encoded string as UTF-8.
	function string_utf8_encode( ( string ) this ) {
		var len = $len( this ), ( array ) arr = $buffer( len );
		call this:get_chars( 0 arr 0 len );
		return arr:utf8_encode( 0 len );
	}

	//# Return a string representation of the specified stack-trace array (or other value).
	function trace_to_string( trace ) {
		var ( list ) list = new_list(), msg = $str( trace );
		call list:add_chars( msg 0 $len( msg ) );
		if $eq( $type( trace ) TYPE_ARRAY ) {
			var idx, len = $len( trace );
			while <( idx len ) {
				var func = [ trace idx++ ];
				if $eq( $type( func ) TYPE_FUNCTION ) {
					let msg = $cat( "\nOn line " $tup( 0 func ) " of '" func "()' in file '" $src( func ) "'." );
					call list:add_chars( msg 0 $len( msg ) );
				} else {
					break;
				}
			}
		}
		return $sub( list.array 0 list.len );
	}

	//# Return an assertion failed message for the specified trace element.
	function assertion_failed( expected, actual, caller ) {
		return $str( "Assertion failed on line " $tup( NULL caller ) " of '"
			$src( caller ) "'. Expected '" expected "', actual '" actual "'." );
	}

	//# Throw an exception if the specified value is FALSE/NULL.
	function assert( value ) {
		if !( value ) {
			throw assertion_failed( "TRUE" "NULL" [ $trace( NULL ) 1 ] );
		}
	}

	//# Throw an exception if the specified values are not equivalent.
	function assert_equals( expected, value ) {
		if $cmp( expected value ) {
			throw assertion_failed( expected value [ $trace( NULL ) 1 ] );
		}
	}

	//# Throw an exception if the specified no-argument function does not throw an
	//# exception with a message that starts with the specified string when compiled and invoked.
	function assert_throws( expected, func ) {
		var err;
		try {
			call :( func );
			let err = "(No exception thrown)";
		} catch err {
			let err = $str( err );
			if <e( $len( expected ) $len( err ) ) {
				let err = $sub( err 0 $len( expected ) );
			}
		}
		if $cmp( expected err ) {
			throw assertion_failed( expected err [ $trace( NULL ) 1 ] );
		}
	}
}
