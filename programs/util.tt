
library util {
	//# Marker struct for string functions.
	struct string {
	}

	//# Marker struct for array functions.
	struct array {
	}

	//# Array-backed list.
	struct list {
		array, len
	}

	//# Simple hash-map with string keys.
	struct map {
		entries
	}

	//# Map entry.
	struct entry {
		key value
	}

	//# Return a new list with an initial capacity of 8.
	function new_list() {
		return $new( list $array( 8 ) );
	}

	//# Add the specified value to the end of the list.
	function list_add( ( list ) this, value ) {
		var arr = this.array, len = this.len;
		if >e( len $len( arr ) ) {
			var idx, old = arr;
			let arr = $array( *( len 2 ) );
			while <( idx len ) {
				let [ arr idx ] = [ old idx++ ];
			}
			let this.array = arr;
		}
		let [ arr len++ ] = value;
		let this.len = len;
	}

	//# Add the specified range from the specified array to the specified list.
	function list_add_array( ( list ) this, arr, idx, len ) {
		var dest = this.array, offset = this.len, end = +( offset len );
		if >( end $len( dest ) ) {
			var old_idx, old = dest;
			let dest = $array( *( end 2 ) );
			while <( old_idx offset ) {
				let [ dest old_idx ] = [ old old_idx++ ];
			}
			let this.array = dest;
		}
		while <( offset end ) {
			let [ dest offset++ ] = [ arr idx++ ];
		}
		let this.len = end;
	}

	//# Insert the specified value into the specified list at the specified index.
	function list_insert( ( list ) this, value, idx ) {
		call list_add( this, value );
		var arr = this.array, len = this.len;
		while <( idx len ) {
			var tmp = [ arr idx ];
			let [ arr idx++ ] = value;
			let value = tmp;
		}
	}

	//# Remove the value at the specified index from the specified list.
	function list_remove( ( list ) this, idx ) {
		var arr = this.array, len = this.len, off = idx, value = [ arr idx++ ];
		while <( idx len ) {
			let [ arr off++ ] = [ arr idx++ ];
		}
		let this.len = -( len 1 );
		return value;
	}

	//# Call the specified function once for each item in the list.
	function list_for_each( ( list ) this, func ) {
		var arr = this.array, len = this.len, idx;
		while <( idx len ) {
			call :( func [ arr idx++ ] );
		}
	}

	//# Find the entry instance with the specified key in the list.
	function list_find_entry( ( list ) this, key ) {
		var arr = this.array, len = this.len, idx;
		while <( idx len ) {
			var ( entry ) entry = [ arr idx++ ];
			if $eq( key entry.key ) {
				return entry;
			}
		}
		return NULL;
	}

	//# Remove the entry with the specified key from the list if present.
	function list_remove_entry( ( list ) this, key ) {
		var arr = this.array, end = -( this.len 1 ), idx;
		while <e( idx end ) {
			var ( entry ) entry = [ arr idx++ ];
			if $eq( key entry.key ) {
				let [ arr -( idx 1 ) ] = [ arr end ];
				let this.len = end;
				return entry;
			}
		}
	}

	//# Create a new hash-map.
	function new_map() {
		var entries = $array( 32 ), idx;
		while <( idx 32 ) {
			let [ entries idx++ ] = new_list();
		}
		return $new( map entries );
	}

	//# Calculate a 5-bit hash-code for the specified string.
	function hash_code( str ) {
		var hash, len = $len( str ), idx;
		while <( idx len ) {
			let hash = ^( hash $chr( str idx++ ) );
		}
		return &( hash 0x1F );
	}

	//# Return the map entry for the specified key, or NULL.
	function map_get_entry( ( map ) this, key ) {
		return list_find_entry( [ this.entries hash_code( key ) ] key );
	}

	//# Return the value for the specified key, or NULL.
	function map_get( ( map ) this, key ) {
		var ( entry ) entry = this:get_entry( key );
		if entry {
			return entry.value;
		}
		return NULL;
	}

	//# Remove the specified entry from the map, if present.
	function map_remove( ( map ) this, key ) {
		return list_remove_entry( [ this.entries hash_code( key ) ], key );
	}

	//# Put the specified value into the map under the specified string key.
	function map_put( ( map ) this, key, value ) {
		var hash = hash_code( key );
		var ( list ) list = [ this.entries hash ];
		var ( entry ) entry = list:find_entry( key );
		if entry {
			let entry.value = value;
		} else {
			call list:add( $new( entry! key value ) );
		}
	}

	//# Call the specified function once for each entry instance in the map.
	function map_for_each( ( map ) this, func ) {
		var entries = this.entries, len = $len( entries ), idx;
		while <( idx len ) {
			call list_for_each( [ entries idx++ ], func );
		}
	}

	//# Call the specified function once for each value in the array.
	function array_for_each( arr, func ) {
		var idx, len = $len( arr );
		while <( idx len ) {
			call :( func [ arr idx++ ] );
		}
	}

	//# Return a new list instance backed by the specified array.
	function array_as_list( arr ) {
		return $new( list arr $len( arr ) );
	}

	//# Return a new array instance containing the specified range.
	function array_slice( arr, offset, len ) {
		var slice = $array( len ), idx;
		while <( offset len ) {
			let [ slice idx++ ] = [ arr offset++ ];
		}
		return slice;
	}

	//# Copy the specified range from the source array to the dest array.
	function array_copy( src src_offset dest dest_offset len ) {
		var src_end = +( src_offset len );
		var dest_end = +( dest_offset len );
		if <( src_end dest_end ) {
			dec src_end;
			dec dest_end;
			while >e( src_end src_offset ) {
				let [ dest dest_end-- ] = [ src src_end-- ];
			}
		} else {
			while <( src_offset src_end ) {
				let [ dest dest_offset++ ] = [ src src_offset++ ];
			}
		}
	}

	//# Return the content of the specified string with leading and trailing spaces removed.
	function string_trim( this ) {
		var idx, end = -( $len( this ) 1 );
		while <e( idx end ) {
			if >( $chr( this idx++ ) 32 ) {
				dec idx;
				while >e( end idx ) {
					if >( $chr( this end-- ) 32 ) {
						return $sub( this idx -( end idx -2 ) );
					}
				}
			}
		}
		return "";
	}

	//# Return an upper-case representation of the specified ASCII string.
	function string_upper( this ) {
		var idx, len = $len( this ), arr = $buffer( len );
		while <( idx len ) {
			var chr = $chr( this idx );
			if >( chr 96 ) {
				if <( chr 123 ) {
					let chr = -( chr 32 );
				}
			}
			let [ arr idx++ ] = chr;
		}
		return $sub( arr 0 len );
	}

	//# Return a lower-case representation of the specified ASCII string.
	function string_lower( this ) {
		var idx, len = $len( this ), arr = $buffer( len );
		while <( idx len ) {
			var chr = $chr( this idx );
			if >( chr 64 ) {
				if <( chr 91 ) {
					let chr = +( chr 32 );
				}
			}
			let [ arr idx++ ] = chr;
		}
		return $sub( arr 0 len );
	}

	//# Return a list instance containing the text between the specified separator characters.
	function string_split( this, separators ) {
		var ( list ) list = new_list();
		var offset, len = $len( this ), end = $stridx( this separators 0 );
		while >e( end 0 ) {
			call list:add( $sub( this offset -( end++ offset ) ) );
			let offset = end;
			let end = ?( <( offset len ) $stridx( this separators offset ) -1 );
		}
		call list:add( $sub( this offset -( len offset ) ) );
		return list;
	}
	
	//# Return the first index of the specified substring within the specified string, or -1.
	function string_find( this, substr, offset ) {
		var sublen = $len( substr ), strend = -( $len( this ) sublen ), firstchr = $sub( substr 0 1 );
		while <e( offset strend ) {
			var idx = $stridx( this firstchr offset );
			if ||( <( idx 0 ) >( idx strend ) ) {
				return -1;
			}
			var end = +( idx++ sublen ), subidx = 1;
			let offset = idx;
			while &&( <( idx end ) =( $chr( this idx ) $chr( substr subidx ) ) ) {
				inc subidx;
				inc idx;
			}
			if >e( idx end ) {
				return -( idx sublen );
			}
		}
		return -1;
	}

	//# Return a UTF-8 encoded string containing the characters in the specified array.
	function array_utf8_encode( this ) {
		var idx, offset, len = $len( this ), ( list ) list = $new( list $buffer( len ) );
		while <( idx len ) {
			var chr = [ this idx++ ];
			if >( chr 127 ) {
				call list:add_array( this offset -( idx offset 1 ) );
				var shift = 6;
				if >>( chr 12 ) {
					let shift = 12;
					if >>( chr 18 ) {
						let shift = 18;
					}
				}
				call list:add( |( 0xC0 &( >>( chr shift ) 0x3F ) ) );
				while shift {
					let shift = -( shift 6 );
					call list:add( |( 0x80 &( >>( chr shift ) 0x3F ) ) );
				}
				let offset = idx;
			}
		}
		if offset {
			if <( offset len ) {
				call list:add_array( this offset -( len offset ) );
			}
			return $sub( list.array 0 list.len );
		}
		return $sub( this 0 len );
	}
}

program test_util {
	var ( string ) str = " @az{ ";
	print $cat( "[" str:trim() "]" );
	print string_lower( str:upper() );
	call list_for_each( string_split( "abc", "a" ) $function( ${ ( value ) { write value; write ","; } } ) );
	print "";
	var ( list ) list = new_list(), idx;
	while <( idx 10 ) {
		call list:insert( idx++ 0 );
	}
	call list:remove( 0 );
	call list:for_each( $function( ${ ( value ) { write value; write ","; } } ) );
	print "";
	var ( map ) map = new_map(), chrs = "abcdefABC";
	let idx = 0;
	while <( idx $len( chrs ) ) {
		call map:put( $sub( chrs idx 1 ), idx++ );
	}
	call map:remove( "C" );
	call map:remove( "c" );
	call map:for_each( $function( ${ ( ( entry ) entry ) { print $cat( entry.key "=>" entry.value ); } } ) );
	var ( array ) arr = $array( 4 1 2 3 4 );
	let arr = arr:slice( 0 3 );
	call arr:copy( 0 arr 1 2 );
	call arr:for_each( $function( ${ ( value ) { write value; write ","; } } ) );
	print "";
	let list = arr:as_list();
	call list:add( 4 );
	call list:for_each( $function( ${ ( value ) { write value; write ","; } } ) );
	print "";
	let arr = $array( 12 48 49 50 51 52 53 54 55 56 0xA3 0x220AC 57 );
	print arr:utf8_encode();
	print array_utf8_encode( arr:slice( 0 10 ) );
	print array_utf8_encode( arr:slice( 0 9 ) );
	print string_find( "abc" "bc" 0 );
}
